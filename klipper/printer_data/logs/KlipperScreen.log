--------------------KlipperScreen Log Start--------------------
Git Version: v0.3.6-65-g4a14962
2023-11-17 18:56:59,315 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'skew_correction': {}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.66', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.83', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set probe_dock_enable = printer["gcode_macro _KAMP_Settings"].probe_dock_enable | abs %}\n{% set attach_macro = printer["gcode_macro _KAMP_Settings"].attach_macro | string %}\n{% set detach_macro = printer["gcode_macro _KAMP_Settings"].detach_macro | string %}\n{% set mesh_margin = printer["gcode_macro _KAMP_Settings"].mesh_margin | float %}\n{% set fuzz_amount = printer["gcode_macro _KAMP_Settings"].fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = (bed_mesh_min[0] + fuzz_amount - mesh_margin, x_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = (bed_mesh_min[1] + fuzz_amount - mesh_margin, y_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = (bed_mesh_max[0] - fuzz_amount + mesh_margin, x_max) | min + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = (bed_mesh_max[1] - fuzz_amount + mesh_margin, y_max) | min + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\nG1 E-.5 F2100\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\nG1 E.5 F2100\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\nG1 E-.5 F2100\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\nG1 E.5 F2100\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\nG1 E-.5 F2100\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | max %}\n{% set y_min = [ y_min - purge_margin , y_min ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'bed_mesh default': {'version': '1', 'points': '\n0.002500, 0.009375, 0.021250, -0.023750, -0.048125\n-0.006250, -0.013125, -0.060625, -0.024375, -0.038125\n-0.049375, -0.081250, -0.078750, -0.080000, -0.091875', 'x_count': '5', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '35.0', 'max_x': '306.56', 'min_y': '29.700000000000003', 'max_y': '110.08'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[0.0025, 0.009375, 0.02125, -0.02375, -0.048125], [-0.00625, -0.013125, -0.060625, -0.024375, -0.038125], [-0.049375, -0.08125, -0.07875, -0.08, -0.091875]], 'min_x': 35.0, 'max_x': 306.56, 'min_y': 29.700000000000003, 'max_y': 110.08, 'x_count': 5, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.66, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.83, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set probe_dock_enable = printer["gcode_macro _KAMP_Settings"].probe_dock_enable | abs %}\n{% set attach_macro = printer["gcode_macro _KAMP_Settings"].attach_macro | string %}\n{% set detach_macro = printer["gcode_macro _KAMP_Settings"].detach_macro | string %}\n{% set mesh_margin = printer["gcode_macro _KAMP_Settings"].mesh_margin | float %}\n{% set fuzz_amount = printer["gcode_macro _KAMP_Settings"].fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = (bed_mesh_min[0] + fuzz_amount - mesh_margin, x_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = (bed_mesh_min[1] + fuzz_amount - mesh_margin, y_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = (bed_mesh_max[0] - fuzz_amount + mesh_margin, x_max) | min + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = (bed_mesh_max[1] - fuzz_amount + mesh_margin, y_max) | min + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\nG1 E-.5 F2100\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\nG1 E.5 F2100\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\nG1 E-.5 F2100\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\nG1 E.5 F2100\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\nG1 E-.5 F2100\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | max %}\n{% set y_min = [ y_min - purge_margin , y_min ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '10', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-17 18:56:59,320 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-11-17 18:56:59,321 [printer.py:reinit()] - # Extruders: 1
2023-11-17 18:56:59,321 [printer.py:reinit()] - # Temperature devices: 5
2023-11-17 18:56:59,321 [printer.py:reinit()] - # Fans: 2
2023-11-17 18:56:59,321 [printer.py:reinit()] - # Output pins: 1
2023-11-17 18:56:59,322 [printer.py:reinit()] - # Leds: 0
2023-11-17 18:56:59,344 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-17 18:56:59,347 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-17 18:56:59,649 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-11-17 18:56:59,672 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-17 18:56:59,673 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-11-17 18:56:59,674 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-17 18:56:59,675 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-17 18:56:59,676 [screen.py:init_printer()] - Printer initialized
2023-11-17 18:56:59,677 [printer.py:change_state()] - Changing state from 'disconnected' to 'ready'
2023-11-17 18:56:59,677 [printer.py:change_state()] - Adding callback for state: ready
2023-11-17 18:56:59,685 [screen.py:_load_panel()] - Loading panel: main_menu
2023-11-17 18:56:59,840 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-17 18:56:59,862 [main_menu.py:add_device()] - Adding device: extruder
2023-11-17 18:56:59,876 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-17 18:56:59,891 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-11-17 18:56:59,905 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-11-17 18:56:59,919 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-11-17 18:56:59,933 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-11-17 18:57:00,032 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-17 18:57:00,035 [main_menu.py:update_graph_visibility()] - Could not create graph tempstore: []
2023-11-17 18:57:05,055 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-17 18:57:05,083 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-11-17 18:57:05,107 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-17 18:57:05,109 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-17 18:59:27,042 [printer.py:change_state()] - Changing state from 'ready' to 'disconnected'
2023-11-17 18:59:27,043 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-17 18:59:27,044 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-17 18:59:27,048 [screen.py:show_panel()] - Reinitializing panel
2023-11-17 18:59:27,139 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-17 18:59:30,334 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-17 18:59:30,352 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-17 18:59:30,353 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'authorization', 'octoprint_compat', 'history'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-17 18:59:30,371 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-17 18:59:30,373 [printer.py:configure_cameras()] - Cameras: []
2023-11-17 18:59:30,392 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-17 18:59:30,425 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-17 18:59:30,429 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'skew_correction': {}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.66', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.83', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set probe_dock_enable = printer["gcode_macro _KAMP_Settings"].probe_dock_enable | abs %}\n{% set attach_macro = printer["gcode_macro _KAMP_Settings"].attach_macro | string %}\n{% set detach_macro = printer["gcode_macro _KAMP_Settings"].detach_macro | string %}\n{% set mesh_margin = printer["gcode_macro _KAMP_Settings"].mesh_margin | float %}\n{% set fuzz_amount = printer["gcode_macro _KAMP_Settings"].fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = (bed_mesh_min[0] + fuzz_amount - mesh_margin, x_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = (bed_mesh_min[1] + fuzz_amount - mesh_margin, y_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = (bed_mesh_max[0] - fuzz_amount + mesh_margin, x_max) | min + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = (bed_mesh_max[1] - fuzz_amount + mesh_margin, y_max) | min + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\nG1 E-.5 F2100\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\nG1 E.5 F2100\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\nG1 E-.5 F2100\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\nG1 E.5 F2100\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\nG1 E-.5 F2100\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | max %}\n{% set y_min = [ y_min - purge_margin , y_min ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'bed_mesh default': {'version': '1', 'points': '\n0.002500, 0.009375, 0.021250, -0.023750, -0.048125\n-0.006250, -0.013125, -0.060625, -0.024375, -0.038125\n-0.049375, -0.081250, -0.078750, -0.080000, -0.091875', 'x_count': '5', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '35.0', 'max_x': '306.56', 'min_y': '29.700000000000003', 'max_y': '110.08'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[0.0025, 0.009375, 0.02125, -0.02375, -0.048125], [-0.00625, -0.013125, -0.060625, -0.024375, -0.038125], [-0.049375, -0.08125, -0.07875, -0.08, -0.091875]], 'min_x': 35.0, 'max_x': 306.56, 'min_y': 29.700000000000003, 'max_y': 110.08, 'x_count': 5, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.66, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.83, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set probe_dock_enable = printer["gcode_macro _KAMP_Settings"].probe_dock_enable | abs %}\n{% set attach_macro = printer["gcode_macro _KAMP_Settings"].attach_macro | string %}\n{% set detach_macro = printer["gcode_macro _KAMP_Settings"].detach_macro | string %}\n{% set mesh_margin = printer["gcode_macro _KAMP_Settings"].mesh_margin | float %}\n{% set fuzz_amount = printer["gcode_macro _KAMP_Settings"].fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = (bed_mesh_min[0] + fuzz_amount - mesh_margin, x_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = (bed_mesh_min[1] + fuzz_amount - mesh_margin, y_min) | max - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = (bed_mesh_max[0] - fuzz_amount + mesh_margin, x_max) | min + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = (bed_mesh_max[1] - fuzz_amount + mesh_margin, y_max) | min + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\nG1 E-.5 F2100\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\nG1 E.5 F2100\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\nG1 E-.5 F2100\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\nG1 E.5 F2100\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\nG1 E-.5 F2100\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | max %}\n{% set y_min = [ y_min - purge_margin , y_min ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-17 18:59:30,435 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-11-17 18:59:30,436 [printer.py:reinit()] - # Extruders: 1
2023-11-17 18:59:30,436 [printer.py:reinit()] - # Temperature devices: 5
2023-11-17 18:59:30,436 [printer.py:reinit()] - # Fans: 2
2023-11-17 18:59:30,436 [printer.py:reinit()] - # Output pins: 1
2023-11-17 18:59:30,436 [printer.py:reinit()] - # Leds: 0
2023-11-17 18:59:30,459 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-17 18:59:30,462 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-17 18:59:30,750 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-11-17 18:59:30,782 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-17 18:59:30,810 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-11-17 18:59:30,834 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-17 18:59:30,836 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-17 18:59:30,837 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-17 18:59:30,838 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-17 18:59:30,839 [screen.py:init_printer()] - Printer initialized
2023-11-17 18:59:30,840 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-17 18:59:30,840 [printer.py:change_state()] - Adding callback for state: startup
2023-11-17 18:59:31,915 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-17 18:59:31,916 [printer.py:change_state()] - Adding callback for state: ready
2023-11-17 18:59:31,922 [screen.py:show_panel()] - Reinitializing panel
2023-11-17 18:59:32,038 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-17 18:59:32,052 [main_menu.py:add_device()] - Adding device: extruder
2023-11-17 18:59:32,061 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-17 18:59:32,073 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-11-17 18:59:32,086 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-11-17 18:59:32,096 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-11-17 18:59:32,106 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-11-17 18:59:32,177 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-17 18:59:53,997 [KlippyGtk.py:Dialog()] - Showing dialog Updating (width=804, height=480)
2023-11-17 18:59:57,019 [base_panel.py:process_update()] - Update complete
2023-11-17 18:59:57,062 [printer.py:change_state()] - Changing state from 'ready' to 'disconnected'
2023-11-17 18:59:57,063 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-17 18:59:57,064 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-17 18:59:57,068 [screen.py:show_panel()] - Reinitializing panel
2023-11-17 18:59:57,155 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-17 19:00:00,337 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-17 19:00:00,361 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-17 19:00:00,363 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'authorization', 'octoprint_compat', 'history'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-17 19:00:00,384 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-17 19:00:00,386 [printer.py:configure_cameras()] - Cameras: []
2023-11-17 19:00:00,458 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-17 19:00:00,502 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-17 19:00:00,507 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'skew_correction': {}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.66', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.83', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'bed_mesh default': {'version': '1', 'points': '\n0.002500, 0.009375, 0.021250, -0.023750, -0.048125\n-0.006250, -0.013125, -0.060625, -0.024375, -0.038125\n-0.049375, -0.081250, -0.078750, -0.080000, -0.091875', 'x_count': '5', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '35.0', 'max_x': '306.56', 'min_y': '29.700000000000003', 'max_y': '110.08'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[0.0025, 0.009375, 0.02125, -0.02375, -0.048125], [-0.00625, -0.013125, -0.060625, -0.024375, -0.038125], [-0.049375, -0.08125, -0.07875, -0.08, -0.091875]], 'min_x': 35.0, 'max_x': 306.56, 'min_y': 29.700000000000003, 'max_y': 110.08, 'x_count': 5, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.66, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.83, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-17 19:00:00,514 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-11-17 19:00:00,515 [printer.py:reinit()] - # Extruders: 1
2023-11-17 19:00:00,515 [printer.py:reinit()] - # Temperature devices: 5
2023-11-17 19:00:00,516 [printer.py:reinit()] - # Fans: 2
2023-11-17 19:00:00,516 [printer.py:reinit()] - # Output pins: 1
2023-11-17 19:00:00,517 [printer.py:reinit()] - # Leds: 0
2023-11-17 19:00:00,546 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-17 19:00:00,550 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-17 19:00:00,820 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-11-17 19:00:00,844 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-17 19:00:00,871 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-11-17 19:00:00,891 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-17 19:00:00,893 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-17 19:00:00,894 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-17 19:00:00,894 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-17 19:00:00,895 [screen.py:init_printer()] - Printer initialized
2023-11-17 19:00:00,896 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-17 19:00:00,897 [printer.py:change_state()] - Adding callback for state: startup
2023-11-17 19:00:02,997 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-17 19:00:02,998 [printer.py:change_state()] - Adding callback for state: ready
2023-11-17 19:00:03,008 [screen.py:show_panel()] - Reinitializing panel
2023-11-17 19:00:03,202 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-17 19:00:03,216 [main_menu.py:add_device()] - Adding device: extruder
2023-11-17 19:00:03,225 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-17 19:00:03,236 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-11-17 19:00:03,248 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-11-17 19:00:03,261 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-11-17 19:00:03,271 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-11-17 19:00:03,336 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-17 19:00:13,453 [base_panel.py:process_update()] - Update complete
2023-11-17 19:00:13,455 [printer.py:change_state()] - Changing state from 'ready' to 'disconnected'
2023-11-17 19:00:13,456 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-17 19:00:13,497 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-17 19:00:13,501 [screen.py:show_panel()] - Reinitializing panel
2023-11-17 19:00:13,584 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-17 19:00:17,333 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-17 19:00:17,352 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-17 19:00:17,354 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'authorization', 'octoprint_compat', 'history'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-17 19:00:17,371 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-17 19:00:17,373 [printer.py:configure_cameras()] - Cameras: []
2023-11-17 19:00:17,393 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-17 19:00:17,434 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-17 19:00:17,439 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'skew_correction': {}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.66', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.83', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'bed_mesh default': {'version': '1', 'points': '\n0.002500, 0.009375, 0.021250, -0.023750, -0.048125\n-0.006250, -0.013125, -0.060625, -0.024375, -0.038125\n-0.049375, -0.081250, -0.078750, -0.080000, -0.091875', 'x_count': '5', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '35.0', 'max_x': '306.56', 'min_y': '29.700000000000003', 'max_y': '110.08'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[0.0025, 0.009375, 0.02125, -0.02375, -0.048125], [-0.00625, -0.013125, -0.060625, -0.024375, -0.038125], [-0.049375, -0.08125, -0.07875, -0.08, -0.091875]], 'min_x': 35.0, 'max_x': 306.56, 'min_y': 29.700000000000003, 'max_y': 110.08, 'x_count': 5, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.66, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.83, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-17 19:00:17,447 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-11-17 19:00:17,448 [printer.py:reinit()] - # Extruders: 1
2023-11-17 19:00:17,448 [printer.py:reinit()] - # Temperature devices: 5
2023-11-17 19:00:17,449 [printer.py:reinit()] - # Fans: 2
2023-11-17 19:00:17,449 [printer.py:reinit()] - # Output pins: 1
2023-11-17 19:00:17,450 [printer.py:reinit()] - # Leds: 0
2023-11-17 19:00:17,480 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-17 19:00:17,484 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-17 19:00:17,752 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-11-17 19:00:17,777 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-17 19:00:17,804 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-11-17 19:00:17,824 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-17 19:00:17,826 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-17 19:00:17,827 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-17 19:00:17,828 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-17 19:00:17,829 [screen.py:init_printer()] - Printer initialized
2023-11-17 19:00:17,830 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-17 19:00:17,830 [printer.py:change_state()] - Adding callback for state: startup
2023-11-17 19:00:19,426 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-17 19:00:19,427 [printer.py:change_state()] - Adding callback for state: ready
2023-11-17 19:00:19,433 [screen.py:show_panel()] - Reinitializing panel
2023-11-17 19:00:19,557 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-17 19:00:19,570 [main_menu.py:add_device()] - Adding device: extruder
2023-11-17 19:00:19,580 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-17 19:00:19,590 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-11-17 19:00:19,600 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-11-17 19:00:19,610 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-11-17 19:00:19,620 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-11-17 19:00:19,693 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-17 19:00:35,477 [printer.py:change_state()] - Changing state from 'ready' to 'disconnected'
2023-11-17 19:00:35,477 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-17 19:00:35,479 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-17 19:00:35,483 [screen.py:show_panel()] - Reinitializing panel
2023-11-17 19:00:35,551 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-17 19:00:39,335 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-17 19:00:39,353 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-17 19:00:39,355 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'authorization', 'octoprint_compat', 'history'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-17 19:00:39,372 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-17 19:00:39,373 [printer.py:configure_cameras()] - Cameras: []
2023-11-17 19:00:39,393 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-17 19:00:39,426 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-17 19:00:39,430 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'skew_correction': {}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.66', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.83', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'bed_mesh default': {'version': '1', 'points': '\n0.002500, 0.009375, 0.021250, -0.023750, -0.048125\n-0.006250, -0.013125, -0.060625, -0.024375, -0.038125\n-0.049375, -0.081250, -0.078750, -0.080000, -0.091875', 'x_count': '5', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '35.0', 'max_x': '306.56', 'min_y': '29.700000000000003', 'max_y': '110.08'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[0.0025, 0.009375, 0.02125, -0.02375, -0.048125], [-0.00625, -0.013125, -0.060625, -0.024375, -0.038125], [-0.049375, -0.08125, -0.07875, -0.08, -0.091875]], 'min_x': 35.0, 'max_x': 306.56, 'min_y': 29.700000000000003, 'max_y': 110.08, 'x_count': 5, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.66, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.83, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-17 19:00:39,436 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-11-17 19:00:39,437 [printer.py:reinit()] - # Extruders: 1
2023-11-17 19:00:39,437 [printer.py:reinit()] - # Temperature devices: 5
2023-11-17 19:00:39,437 [printer.py:reinit()] - # Fans: 2
2023-11-17 19:00:39,437 [printer.py:reinit()] - # Output pins: 1
2023-11-17 19:00:39,437 [printer.py:reinit()] - # Leds: 0
2023-11-17 19:00:39,461 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-17 19:00:39,465 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-17 19:00:39,749 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-11-17 19:00:39,777 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-17 19:00:39,804 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-11-17 19:00:39,829 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-17 19:00:39,831 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-17 19:00:39,832 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-17 19:00:39,833 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-17 19:00:39,834 [screen.py:init_printer()] - Printer initialized
2023-11-17 19:00:39,835 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-17 19:00:39,836 [printer.py:change_state()] - Adding callback for state: startup
2023-11-17 19:00:40,416 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-17 19:00:40,416 [printer.py:change_state()] - Adding callback for state: ready
2023-11-17 19:00:40,422 [screen.py:show_panel()] - Reinitializing panel
2023-11-17 19:00:40,540 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-17 19:00:40,553 [main_menu.py:add_device()] - Adding device: extruder
2023-11-17 19:00:40,563 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-17 19:00:40,574 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-11-17 19:00:40,586 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-11-17 19:00:40,600 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-11-17 19:00:40,614 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-11-17 19:00:40,719 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-17 19:04:32,161 [files.py:_callback()] - Error in getting metadata for .thumbs/frame_brace_gantry-32x32.png. Retrying in 6 seconds
2023-11-17 19:04:32,166 [files.py:_callback()] - Error in getting metadata for .thumbs/frame_brace_gantry-400x300.png. Retrying in 6 seconds
2023-11-17 19:04:32,347 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-11-17 19:04:32,347 [printer.py:change_state()] - Adding callback for state: printing
2023-11-17 19:04:32,373 [screen.py:_load_panel()] - Loading panel: job_status
2023-11-17 19:04:32,645 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-11-17 19:04:32,657 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-11-17 19:04:32,688 [job_status.py:update_file_metadata()] - Update Metadata. File: frame_brace_gantry.gcode Size: 4304706
2023-11-17 19:04:32,703 [job_status.py:show_file_thumbnail()] - frame_brace_gantry.gcode
2023-11-17 19:10:57,770 [base_panel.py:finish_updating()] - Finishing update
2023-11-17 19:10:57,782 [KlippyGtk.py:remove_dialog()] - Removing Dialog
2023-11-17 19:10:57,783 [screen.py:_menu_go_back()] - #### Menu go home
2023-11-17 19:10:57,844 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-11-17 19:10:57,871 [job_status.py:update_file_metadata()] - Update Metadata. File: frame_brace_gantry.gcode Size: 4304706
2023-11-17 19:10:57,882 [job_status.py:show_file_thumbnail()] - frame_brace_gantry.gcode
2023-11-17 20:10:58,318 [screen.py:show_screensaver()] - Showing Screensaver
2023-11-17 21:10:53,838 [screen.py:close_screensaver()] - Closing Screensaver
2023-11-17 21:10:53,865 [screen.py:wake_screen()] - Screen wake up
2023-11-17 21:10:53,918 [job_status.py:set_state()] - Changing job_status state from 'printing' to 'complete'
2023-11-17 21:10:59,588 [printer.py:change_state()] - Changing state from 'printing' to 'ready'
2023-11-17 21:10:59,589 [printer.py:change_state()] - Adding callback for state: ready
2023-11-17 21:30:19,706 [files.py:_callback()] - Error in getting metadata for .thumbs/idler_left_lower-32x32.png. Retrying in 6 seconds
2023-11-17 21:30:19,710 [files.py:_callback()] - Error in getting metadata for .thumbs/idler_left_lower-400x300.png. Retrying in 6 seconds
2023-11-17 21:30:19,876 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-11-17 21:30:19,877 [printer.py:change_state()] - Adding callback for state: printing
2023-11-17 21:30:19,892 [job_status.py:set_state()] - Changing job_status state from 'complete' to 'printing'
2023-11-17 21:30:19,902 [job_status.py:update_file_metadata()] - Update Metadata. File: idler_left_lower.gcode Size: 22931001
2023-11-17 21:30:19,912 [job_status.py:show_file_thumbnail()] - idler_left_lower.gcode
2023-11-17 21:30:19,977 [screen.py:show_panel()] - Reinitializing panel
2023-11-17 21:30:20,194 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-11-17 21:30:20,205 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-11-17 21:30:20,221 [job_status.py:update_file_metadata()] - Update Metadata. File: idler_left_lower.gcode Size: 22931001
2023-11-17 21:30:20,231 [job_status.py:show_file_thumbnail()] - idler_left_lower.gcode
2023-11-17 22:10:54,317 [screen.py:show_screensaver()] - Showing Screensaver
2023-11-18 04:09:22,778 [screen.py:close_screensaver()] - Closing Screensaver
2023-11-18 04:09:22,807 [screen.py:wake_screen()] - Screen wake up
2023-11-18 04:09:22,861 [job_status.py:set_state()] - Changing job_status state from 'printing' to 'complete'
2023-11-18 04:09:27,789 [printer.py:change_state()] - Changing state from 'printing' to 'ready'
2023-11-18 04:09:27,790 [printer.py:change_state()] - Adding callback for state: ready
2023-11-18 04:54:53,460 [files.py:_callback()] - Error in getting metadata for .thumbs/mirrLOhinge_door_side-32x32.png. Retrying in 6 seconds
2023-11-18 04:54:53,464 [files.py:_callback()] - Error in getting metadata for .thumbs/mirrLOhinge_door_side-400x300.png. Retrying in 6 seconds
2023-11-18 04:54:53,593 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-11-18 04:54:53,594 [printer.py:change_state()] - Adding callback for state: printing
2023-11-18 04:54:53,614 [job_status.py:set_state()] - Changing job_status state from 'complete' to 'printing'
2023-11-18 04:54:53,626 [job_status.py:update_file_metadata()] - Update Metadata. File: mirrLOhinge_door_side.gcode Size: 8276958
2023-11-18 04:54:53,635 [job_status.py:show_file_thumbnail()] - mirrLOhinge_door_side.gcode
2023-11-18 04:54:53,710 [screen.py:show_panel()] - Reinitializing panel
2023-11-18 04:54:53,960 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-11-18 04:54:53,972 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-11-18 04:54:53,988 [job_status.py:update_file_metadata()] - Update Metadata. File: mirrLOhinge_door_side.gcode Size: 8276958
2023-11-18 04:54:53,998 [job_status.py:show_file_thumbnail()] - mirrLOhinge_door_side.gcode
2023-11-18 04:55:49,245 [printer.py:change_state()] - Changing state from 'printing' to 'shutdown'
2023-11-18 04:55:49,246 [printer.py:change_state()] - Adding callback for state: shutdown
2023-11-18 04:55:49,293 [screen.py:show_panel()] - Reinitializing panel
2023-11-18 04:55:49,363 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-18 04:55:54,450 [printer.py:change_state()] - Changing state from 'shutdown' to 'disconnected'
2023-11-18 04:55:54,451 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-18 04:55:54,453 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-18 04:55:54,456 [screen.py:show_panel()] - Reinitializing panel
2023-11-18 04:55:54,560 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-18 04:55:58,336 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 04:55:58,353 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 04:55:58,355 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'authorization', 'octoprint_compat', 'history'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-18 04:55:58,372 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-18 04:55:58,374 [printer.py:configure_cameras()] - Cameras: []
2023-11-18 04:55:58,396 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-18 04:55:58,429 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-18 04:55:58,433 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'skew_correction': {}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.66', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.83', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'bed_mesh default': {'version': '1', 'points': '\n0.002500, 0.009375, 0.021250, -0.023750, -0.048125\n-0.006250, -0.013125, -0.060625, -0.024375, -0.038125\n-0.049375, -0.081250, -0.078750, -0.080000, -0.091875', 'x_count': '5', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '35.0', 'max_x': '306.56', 'min_y': '29.700000000000003', 'max_y': '110.08'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[0.0025, 0.009375, 0.02125, -0.02375, -0.048125], [-0.00625, -0.013125, -0.060625, -0.024375, -0.038125], [-0.049375, -0.08125, -0.07875, -0.08, -0.091875]], 'min_x': 35.0, 'max_x': 306.56, 'min_y': 29.700000000000003, 'max_y': 110.08, 'x_count': 5, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.66, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.83, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-18 04:55:58,441 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-11-18 04:55:58,441 [printer.py:reinit()] - # Extruders: 1
2023-11-18 04:55:58,441 [printer.py:reinit()] - # Temperature devices: 5
2023-11-18 04:55:58,442 [printer.py:reinit()] - # Fans: 2
2023-11-18 04:55:58,442 [printer.py:reinit()] - # Output pins: 1
2023-11-18 04:55:58,442 [printer.py:reinit()] - # Leds: 0
2023-11-18 04:55:58,465 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-18 04:55:58,468 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-18 04:55:58,776 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-11-18 04:55:58,852 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-18 04:55:58,862 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-11-18 04:55:58,885 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-18 04:55:58,887 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-18 04:55:58,888 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-18 04:55:58,889 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-18 04:55:58,890 [screen.py:init_printer()] - Printer initialized
2023-11-18 04:55:58,891 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-18 04:55:58,892 [printer.py:change_state()] - Adding callback for state: startup
2023-11-18 04:55:59,426 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-18 04:55:59,426 [printer.py:change_state()] - Adding callback for state: ready
2023-11-18 04:55:59,433 [screen.py:show_panel()] - Reinitializing panel
2023-11-18 04:55:59,550 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-18 04:55:59,564 [main_menu.py:add_device()] - Adding device: extruder
2023-11-18 04:55:59,574 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-18 04:55:59,584 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-11-18 04:55:59,594 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-11-18 04:55:59,604 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-11-18 04:55:59,614 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-11-18 04:55:59,684 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-18 04:56:48,569 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-11-18 04:56:48,570 [printer.py:change_state()] - Adding callback for state: printing
2023-11-18 04:56:48,597 [screen.py:show_panel()] - Reinitializing panel
2023-11-18 04:56:48,831 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-11-18 04:56:48,843 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-11-18 04:56:48,863 [job_status.py:update_file_metadata()] - Update Metadata. File: mirrLOhinge_door_side.gcode Size: 8276958
2023-11-18 04:56:48,873 [job_status.py:show_file_thumbnail()] - mirrLOhinge_door_side.gcode
2023-11-18 04:56:49,558 [files.py:add_file()] - File already exists: mirrLOhinge_door_side.gcode
2023-11-18 05:09:23,317 [screen.py:show_screensaver()] - Showing Screensaver
2023-11-18 10:56:29,227 [screen.py:close_screensaver()] - Closing Screensaver
2023-11-18 10:56:29,266 [screen.py:wake_screen()] - Screen wake up
2023-11-18 10:56:29,327 [job_status.py:set_state()] - Changing job_status state from 'printing' to 'complete'
2023-11-18 10:56:35,469 [printer.py:change_state()] - Changing state from 'printing' to 'ready'
2023-11-18 10:56:35,470 [printer.py:change_state()] - Adding callback for state: ready
2023-11-18 11:24:16,705 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-11-18 11:24:16,706 [printer.py:change_state()] - Adding callback for state: printing
2023-11-18 11:24:16,719 [job_status.py:set_state()] - Changing job_status state from 'complete' to 'printing'
2023-11-18 11:24:16,764 [screen.py:show_panel()] - Reinitializing panel
2023-11-18 11:24:16,975 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-11-18 11:24:16,987 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-11-18 11:24:17,003 [job_status.py:update_file_metadata()] - Update Metadata. File: mirrLOhinge_door_side.gcode Size: 4939587
2023-11-18 11:24:17,013 [job_status.py:show_file_thumbnail()] - mirrLOhinge_door_side.gcode
2023-11-18 11:24:17,645 [files.py:add_file()] - File already exists: mirrLOhinge_door_side.gcode
2023-11-18 11:25:14,622 [printer.py:change_state()] - Changing state from 'printing' to 'shutdown'
2023-11-18 11:25:14,623 [printer.py:change_state()] - Adding callback for state: shutdown
2023-11-18 11:25:14,671 [screen.py:show_panel()] - Reinitializing panel
2023-11-18 11:25:14,744 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-18 11:25:20,470 [printer.py:change_state()] - Changing state from 'shutdown' to 'disconnected'
2023-11-18 11:25:20,471 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-18 11:25:20,473 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-18 11:25:20,477 [screen.py:show_panel()] - Reinitializing panel
2023-11-18 11:25:20,556 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-18 11:25:24,335 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 11:25:24,352 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 11:25:24,354 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'authorization', 'octoprint_compat', 'history'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-18 11:25:24,372 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-18 11:25:24,374 [printer.py:configure_cameras()] - Cameras: []
2023-11-18 11:25:24,393 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-18 11:25:24,429 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-18 11:25:24,433 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'skew_correction': {}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.66', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.83', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'bed_mesh default': {'version': '1', 'points': '\n0.002500, 0.009375, 0.021250, -0.023750, -0.048125\n-0.006250, -0.013125, -0.060625, -0.024375, -0.038125\n-0.049375, -0.081250, -0.078750, -0.080000, -0.091875', 'x_count': '5', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '35.0', 'max_x': '306.56', 'min_y': '29.700000000000003', 'max_y': '110.08'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[0.0025, 0.009375, 0.02125, -0.02375, -0.048125], [-0.00625, -0.013125, -0.060625, -0.024375, -0.038125], [-0.049375, -0.08125, -0.07875, -0.08, -0.091875]], 'min_x': 35.0, 'max_x': 306.56, 'min_y': 29.700000000000003, 'max_y': 110.08, 'x_count': 5, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.66, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.83, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-18 11:25:24,440 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-11-18 11:25:24,440 [printer.py:reinit()] - # Extruders: 1
2023-11-18 11:25:24,441 [printer.py:reinit()] - # Temperature devices: 5
2023-11-18 11:25:24,441 [printer.py:reinit()] - # Fans: 2
2023-11-18 11:25:24,441 [printer.py:reinit()] - # Output pins: 1
2023-11-18 11:25:24,441 [printer.py:reinit()] - # Leds: 0
2023-11-18 11:25:24,463 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-18 11:25:24,466 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-18 11:25:24,748 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-11-18 11:25:24,803 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-18 11:25:24,814 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-11-18 11:25:24,836 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-18 11:25:24,838 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-18 11:25:24,839 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-18 11:25:24,840 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-18 11:25:24,841 [screen.py:init_printer()] - Printer initialized
2023-11-18 11:25:24,842 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-18 11:25:24,843 [printer.py:change_state()] - Adding callback for state: startup
2023-11-18 11:25:25,415 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-18 11:25:25,416 [printer.py:change_state()] - Adding callback for state: ready
2023-11-18 11:25:25,422 [screen.py:show_panel()] - Reinitializing panel
2023-11-18 11:25:25,541 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-18 11:25:25,554 [main_menu.py:add_device()] - Adding device: extruder
2023-11-18 11:25:25,564 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-18 11:25:25,574 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-11-18 11:25:25,584 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-11-18 11:25:25,594 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-11-18 11:25:25,604 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-11-18 11:25:25,677 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-18 11:26:31,112 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-11-18 11:26:31,113 [printer.py:change_state()] - Adding callback for state: printing
2023-11-18 11:26:31,137 [screen.py:show_panel()] - Reinitializing panel
2023-11-18 11:26:31,400 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-11-18 11:26:31,411 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-11-18 11:26:31,428 [job_status.py:update_file_metadata()] - Update Metadata. File: mirrLOhinge_door_side.gcode Size: 7363542
2023-11-18 11:26:31,438 [job_status.py:show_file_thumbnail()] - mirrLOhinge_door_side.gcode
2023-11-18 11:26:31,971 [files.py:add_file()] - File already exists: mirrLOhinge_door_side.gcode
2023-11-18 11:56:29,318 [screen.py:show_screensaver()] - Showing Screensaver
2023-11-18 14:45:41,941 [screen.py:close_screensaver()] - Closing Screensaver
2023-11-18 14:45:41,965 [screen.py:wake_screen()] - Screen wake up
2023-11-18 14:45:42,021 [job_status.py:set_state()] - Changing job_status state from 'printing' to 'complete'
2023-11-18 14:45:47,445 [printer.py:change_state()] - Changing state from 'printing' to 'ready'
2023-11-18 14:45:47,446 [printer.py:change_state()] - Adding callback for state: ready
2023-11-18 15:45:42,319 [screen.py:show_screensaver()] - Showing Screensaver
2023-11-18 18:40:17,906 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-11-18 18:40:17,907 [printer.py:change_state()] - Adding callback for state: printing
2023-11-18 18:40:17,925 [job_status.py:set_state()] - Changing job_status state from 'complete' to 'printing'
2023-11-18 18:40:17,932 [screen.py:close_screensaver()] - Closing Screensaver
2023-11-18 18:40:17,959 [screen.py:wake_screen()] - Screen wake up
2023-11-18 18:40:18,017 [screen.py:show_panel()] - Reinitializing panel
2023-11-18 18:40:18,241 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-11-18 18:40:18,253 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-11-18 18:40:18,269 [job_status.py:update_file_metadata()] - Update Metadata. File: mirrLOhinge_door_side.gcode Size: 2542296
2023-11-18 18:40:18,278 [job_status.py:show_file_thumbnail()] - mirrLOhinge_door_side.gcode
2023-11-18 18:40:18,782 [files.py:add_file()] - File already exists: mirrLOhinge_door_side.gcode
2023-11-18 19:40:18,358 [screen.py:show_screensaver()] - Showing Screensaver
2023-11-18 20:00:45,325 [screen.py:close_screensaver()] - Closing Screensaver
2023-11-18 20:00:45,374 [screen.py:wake_screen()] - Screen wake up
2023-11-18 20:00:45,428 [job_status.py:set_state()] - Changing job_status state from 'printing' to 'complete'
2023-11-18 20:00:51,568 [printer.py:change_state()] - Changing state from 'printing' to 'ready'
2023-11-18 20:00:51,568 [printer.py:change_state()] - Adding callback for state: ready
2023-11-18 20:25:17,779 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-11-18 20:25:17,780 [printer.py:change_state()] - Adding callback for state: printing
2023-11-18 20:25:17,791 [job_status.py:set_state()] - Changing job_status state from 'complete' to 'printing'
2023-11-18 20:25:17,838 [screen.py:show_panel()] - Reinitializing panel
2023-11-18 20:25:18,052 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-11-18 20:25:18,064 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-11-18 20:25:18,080 [job_status.py:update_file_metadata()] - Update Metadata. File: mirrLOhinge_door_side.gcode Size: 3373434
2023-11-18 20:25:18,089 [job_status.py:show_file_thumbnail()] - mirrLOhinge_door_side.gcode
2023-11-18 20:25:18,709 [files.py:add_file()] - File already exists: mirrLOhinge_door_side.gcode
2023-11-18 21:00:46,324 [screen.py:show_screensaver()] - Showing Screensaver
2023-11-18 22:33:13,370 [screen.py:close_screensaver()] - Closing Screensaver
2023-11-18 22:33:13,395 [screen.py:wake_screen()] - Screen wake up
2023-11-18 22:33:13,449 [job_status.py:set_state()] - Changing job_status state from 'printing' to 'complete'
2023-11-18 22:33:18,870 [printer.py:change_state()] - Changing state from 'printing' to 'ready'
2023-11-18 22:33:18,870 [printer.py:change_state()] - Adding callback for state: ready
2023-11-18 23:33:14,317 [screen.py:show_screensaver()] - Showing Screensaver
--------------------KlipperScreen Log Start--------------------
Git Version: v0.3.6-65-g4a14962
2023-11-18 23:17:23,466 [screen.py:main()] - Python version: 3.9
2023-11-18 23:17:23,467 [screen.py:main()] - KlipperScreen version: v0.3.6-65-g4a14962
2023-11-18 23:17:23,475 [functions.py:detect_desktop_environment()] - Error:
'XDG_CURRENT_DESKTOP'

Traceback (most recent call last):
  File "/home/biqu/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.9/os.py", line 679, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
Traceback (most recent call last):
  File "/home/biqu/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.9/os.py", line 679, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
2023-11-18 23:17:23,741 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-11-18 23:17:23,744 [config.py:__init__()] - Config path location: /home/biqu/printer_data/config/KlipperScreen.conf
2023-11-18 23:17:23,780 [config.py:log_config()] -  ===== Config File =====

=======================
2023-11-18 23:17:23,783 [config.py:__init__()] - ====== Saved Def ======

[main]
print_sort_dir = date_asc

=======================
2023-11-18 23:17:23,785 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-11-18 23:17:23,888 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-11-18 23:17:23,889 [config.py:install_language()] - Using system lang
2023-11-18 23:17:23,889 [config.py:install_language()] - Using lang en
2023-11-18 23:17:23,919 [screen.py:__init__()] - Screen resolution: 800x480
2023-11-18 23:17:23,922 [KlippyGtk.py:__init__()] - Font size: 16.6 (medium)
2023-11-18 23:17:25,482 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-11-18 23:17:25,495 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-11-18 23:17:25,506 [screen.py:initial_connection()] - Default printer: None
2023-11-18 23:17:25,506 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-11-18 23:17:25,507 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-11-18 23:17:25,618 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-18 23:17:25,640 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-11-18 23:17:25,681 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 23:17:25,708 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-11-18 23:17:25,711 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-11-18 23:17:25,729 [_logging.py:info()] - Websocket connected
2023-11-18 23:17:25,730 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-11-18 23:17:26,094 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 23:17:26,122 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 23:17:26,124 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'history', 'octoprint_compat', 'authorization'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-18 23:17:26,147 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-18 23:17:26,149 [printer.py:configure_cameras()] - Cameras: []
2023-11-18 23:17:26,150 [screen.py:init_printer()] - Klipper not connected
2023-11-18 23:17:29,044 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 23:17:29,068 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 23:17:29,070 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'history', 'octoprint_compat', 'authorization'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-18 23:17:29,090 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-18 23:17:29,092 [printer.py:configure_cameras()] - Cameras: []
2023-11-18 23:17:29,092 [screen.py:init_printer()] - Klipper not connected
2023-11-18 23:17:32,030 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 23:17:32,049 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 23:17:32,051 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'history', 'octoprint_compat', 'authorization'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-18 23:17:32,069 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-18 23:17:32,071 [printer.py:configure_cameras()] - Cameras: []
2023-11-18 23:17:32,104 [KlippyRest.py:_do_request()] - 404 Client Error>>Not Found for url>>http://127.0.0.1:7125/printer/info
2023-11-18 23:17:35,032 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 23:17:35,052 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-18 23:17:35,054 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'history', 'octoprint_compat', 'authorization'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-18 23:17:35,075 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-18 23:17:35,076 [printer.py:configure_cameras()] - Cameras: []
2023-11-18 23:17:35,106 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-18 23:17:35,140 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-18 23:17:35,145 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'skew_correction': {}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.66', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.83', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'bed_mesh default': {'version': '1', 'points': '\n0.002500, 0.009375, 0.021250, -0.023750, -0.048125\n-0.006250, -0.013125, -0.060625, -0.024375, -0.038125\n-0.049375, -0.081250, -0.078750, -0.080000, -0.091875', 'x_count': '5', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '35.0', 'max_x': '306.56', 'min_y': '29.700000000000003', 'max_y': '110.08'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[0.0025, 0.009375, 0.02125, -0.02375, -0.048125], [-0.00625, -0.013125, -0.060625, -0.024375, -0.038125], [-0.049375, -0.08125, -0.07875, -0.08, -0.091875]], 'min_x': 35.0, 'max_x': 306.56, 'min_y': 29.700000000000003, 'max_y': 110.08, 'x_count': 5, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.66, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.83, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-18 23:17:35,150 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-11-18 23:17:35,150 [printer.py:reinit()] - # Extruders: 1
2023-11-18 23:17:35,150 [printer.py:reinit()] - # Temperature devices: 5
2023-11-18 23:17:35,150 [printer.py:reinit()] - # Fans: 2
2023-11-18 23:17:35,151 [printer.py:reinit()] - # Output pins: 1
2023-11-18 23:17:35,151 [printer.py:reinit()] - # Leds: 0
2023-11-18 23:17:35,174 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-18 23:17:35,177 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-18 23:17:35,468 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-11-18 23:17:35,488 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-18 23:17:35,490 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-11-18 23:17:35,491 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-18 23:17:35,491 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-18 23:17:35,493 [screen.py:init_printer()] - Printer initialized
2023-11-18 23:17:35,494 [printer.py:change_state()] - Changing state from 'disconnected' to 'ready'
2023-11-18 23:17:35,494 [printer.py:change_state()] - Adding callback for state: ready
2023-11-18 23:17:35,499 [screen.py:_load_panel()] - Loading panel: main_menu
2023-11-18 23:17:35,644 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-18 23:17:35,658 [main_menu.py:add_device()] - Adding device: extruder
2023-11-18 23:17:35,669 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-18 23:17:35,679 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-11-18 23:17:35,690 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-11-18 23:17:35,702 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-11-18 23:17:35,714 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-11-18 23:17:35,791 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-18 23:17:35,794 [main_menu.py:update_graph_visibility()] - Could not create graph tempstore: []
2023-11-18 23:17:41,028 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-18 23:17:41,056 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-11-18 23:17:41,078 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-18 23:17:41,081 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-19 10:30:24,037 [files.py:_callback()] - Error in getting metadata for .thumbs/mainboard - dtx-v3-32x32.png. Retrying in 6 seconds
2023-11-19 10:30:24,041 [files.py:_callback()] - Error in getting metadata for .thumbs/mainboard - dtx-v3-400x300.png. Retrying in 6 seconds
2023-11-19 10:30:24,243 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-11-19 10:30:24,244 [printer.py:change_state()] - Adding callback for state: printing
2023-11-19 10:30:24,270 [screen.py:_load_panel()] - Loading panel: job_status
2023-11-19 10:30:24,519 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-11-19 10:30:24,533 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-11-19 10:30:24,562 [job_status.py:update_file_metadata()] - Update Metadata. File: mainboard - dtx-v3.gcode Size: 5181923
2023-11-19 10:30:24,577 [job_status.py:show_file_thumbnail()] - mainboard - dtx-v3.gcode
2023-11-19 11:18:22,803 [screen.py:show_screensaver()] - Showing Screensaver
2023-11-19 17:17:57,442 [screen.py:close_screensaver()] - Closing Screensaver
2023-11-19 17:17:57,470 [screen.py:wake_screen()] - Screen wake up
2023-11-19 17:17:57,524 [job_status.py:set_state()] - Changing job_status state from 'printing' to 'complete'
2023-11-19 17:18:02,951 [printer.py:change_state()] - Changing state from 'printing' to 'ready'
2023-11-19 17:18:02,951 [printer.py:change_state()] - Adding callback for state: ready
2023-11-19 18:17:57,804 [screen.py:show_screensaver()] - Showing Screensaver
2023-11-19 18:36:09,270 [files.py:_callback()] - Error in getting metadata for .thumbs/z_joint_rear (1)-32x32.png. Retrying in 6 seconds
2023-11-19 18:36:09,272 [files.py:_callback()] - Error in getting metadata for .thumbs/z_joint_rear (1)-400x300.png. Retrying in 6 seconds
2023-11-19 18:36:09,311 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-11-19 18:36:09,311 [printer.py:change_state()] - Adding callback for state: printing
2023-11-19 18:36:09,323 [job_status.py:set_state()] - Changing job_status state from 'complete' to 'printing'
2023-11-19 18:36:09,326 [job_status.py:update_file_metadata()] - Update Metadata. File: z_joint_rear (1).gcode Size: 5707075
2023-11-19 18:36:09,336 [job_status.py:show_file_thumbnail()] - z_joint_rear (1).gcode
2023-11-19 18:36:09,342 [screen.py:close_screensaver()] - Closing Screensaver
2023-11-19 18:36:09,362 [screen.py:wake_screen()] - Screen wake up
2023-11-19 18:36:09,418 [screen.py:show_panel()] - Reinitializing panel
2023-11-19 18:36:09,656 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-11-19 18:36:09,667 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-11-19 18:36:09,683 [job_status.py:update_file_metadata()] - Update Metadata. File: z_joint_rear (1).gcode Size: 5707075
2023-11-19 18:36:09,692 [job_status.py:show_file_thumbnail()] - z_joint_rear (1).gcode
2023-11-19 19:36:09,804 [screen.py:show_screensaver()] - Showing Screensaver
2023-11-19 20:46:37,129 [screen.py:close_screensaver()] - Closing Screensaver
2023-11-19 20:46:37,156 [screen.py:wake_screen()] - Screen wake up
2023-11-19 20:46:37,210 [job_status.py:set_state()] - Changing job_status state from 'printing' to 'complete'
2023-11-19 20:46:42,641 [printer.py:change_state()] - Changing state from 'printing' to 'ready'
2023-11-19 20:46:42,642 [printer.py:change_state()] - Adding callback for state: ready
--------------------KlipperScreen Log Start--------------------
Git Version: v0.3.6-65-g4a14962
2023-11-19 21:17:20,622 [screen.py:main()] - Python version: 3.9
2023-11-19 21:17:20,622 [screen.py:main()] - KlipperScreen version: v0.3.6-65-g4a14962
2023-11-19 21:17:20,654 [functions.py:detect_desktop_environment()] - Error:
'XDG_CURRENT_DESKTOP'

Traceback (most recent call last):
  File "/home/biqu/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.9/os.py", line 679, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
Traceback (most recent call last):
  File "/home/biqu/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.9/os.py", line 679, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
2023-11-19 21:17:21,014 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-11-19 21:17:21,017 [config.py:__init__()] - Config path location: /home/biqu/printer_data/config/KlipperScreen.conf
2023-11-19 21:17:21,054 [config.py:log_config()] -  ===== Config File =====

=======================
2023-11-19 21:17:21,057 [config.py:__init__()] - ====== Saved Def ======

[main]
print_sort_dir = date_asc

=======================
2023-11-19 21:17:21,058 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-11-19 21:17:21,217 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-11-19 21:17:21,218 [config.py:install_language()] - Using system lang
2023-11-19 21:17:21,219 [config.py:install_language()] - Using lang en
2023-11-19 21:17:21,256 [screen.py:__init__()] - Screen resolution: 800x480
2023-11-19 21:17:21,259 [KlippyGtk.py:__init__()] - Font size: 16.6 (medium)
2023-11-19 21:17:23,377 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-11-19 21:17:23,401 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-11-19 21:17:23,424 [screen.py:initial_connection()] - Default printer: None
2023-11-19 21:17:23,424 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-11-19 21:17:23,425 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-11-19 21:17:23,599 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-19 21:17:23,635 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-11-19 21:17:23,856 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-19 21:17:23,895 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-11-19 21:17:23,898 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-11-19 21:17:23,920 [_logging.py:info()] - Websocket connected
2023-11-19 21:17:23,921 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-11-19 21:17:24,564 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-19 21:17:24,607 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-19 21:17:24,610 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'history', 'update_manager', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-19 21:17:24,645 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-19 21:17:24,651 [printer.py:configure_cameras()] - Cameras: []
2023-11-19 21:17:24,652 [screen.py:init_printer()] - Klipper not connected
2023-11-19 21:17:27,689 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-19 21:17:27,707 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-19 21:17:27,709 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'history', 'update_manager', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-19 21:17:27,727 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-19 21:17:27,729 [printer.py:configure_cameras()] - Cameras: []
2023-11-19 21:17:27,729 [screen.py:init_printer()] - Klipper not connected
2023-11-19 21:17:30,690 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-19 21:17:30,710 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-19 21:17:30,712 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'history', 'update_manager', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-19 21:17:30,732 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-19 21:17:30,734 [printer.py:configure_cameras()] - Cameras: []
2023-11-19 21:17:30,781 [KlippyRest.py:_do_request()] - 404 Client Error>>Not Found for url>>http://127.0.0.1:7125/printer/info
2023-11-19 21:17:33,687 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-19 21:17:33,705 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-19 21:17:33,707 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'history', 'update_manager', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-19 21:17:33,724 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-19 21:17:33,726 [printer.py:configure_cameras()] - Cameras: []
2023-11-19 21:17:33,746 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-19 21:17:33,780 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-19 21:17:33,784 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'skew_correction': {}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.66', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.83', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'bed_mesh default': {'version': '1', 'points': '\n0.002500, 0.009375, 0.021250, -0.023750, -0.048125\n-0.006250, -0.013125, -0.060625, -0.024375, -0.038125\n-0.049375, -0.081250, -0.078750, -0.080000, -0.091875', 'x_count': '5', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '35.0', 'max_x': '306.56', 'min_y': '29.700000000000003', 'max_y': '110.08'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[0.0025, 0.009375, 0.02125, -0.02375, -0.048125], [-0.00625, -0.013125, -0.060625, -0.024375, -0.038125], [-0.049375, -0.08125, -0.07875, -0.08, -0.091875]], 'min_x': 35.0, 'max_x': 306.56, 'min_y': 29.700000000000003, 'max_y': 110.08, 'x_count': 5, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.66, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.83, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-19 21:17:33,789 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-11-19 21:17:33,790 [printer.py:reinit()] - # Extruders: 1
2023-11-19 21:17:33,790 [printer.py:reinit()] - # Temperature devices: 5
2023-11-19 21:17:33,790 [printer.py:reinit()] - # Fans: 2
2023-11-19 21:17:33,790 [printer.py:reinit()] - # Output pins: 1
2023-11-19 21:17:33,790 [printer.py:reinit()] - # Leds: 0
2023-11-19 21:17:33,814 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-19 21:17:33,817 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-19 21:17:34,106 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-11-19 21:17:34,200 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-19 21:17:34,203 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-11-19 21:17:34,204 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-19 21:17:34,205 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-19 21:17:34,207 [screen.py:init_printer()] - Printer initialized
2023-11-19 21:17:34,208 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-19 21:17:34,209 [printer.py:change_state()] - Adding callback for state: startup
2023-11-19 21:17:34,781 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-19 21:17:34,782 [printer.py:change_state()] - Adding callback for state: ready
2023-11-19 21:17:34,787 [screen.py:_load_panel()] - Loading panel: main_menu
2023-11-19 21:17:34,924 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-19 21:17:34,937 [main_menu.py:add_device()] - Adding device: extruder
2023-11-19 21:17:34,949 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-19 21:17:34,960 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-11-19 21:17:34,970 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-11-19 21:17:34,980 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-11-19 21:17:34,990 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-11-19 21:17:35,064 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-19 21:17:35,067 [main_menu.py:update_graph_visibility()] - Could not create graph tempstore: []
2023-11-19 21:17:39,687 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-19 21:17:39,715 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-11-19 21:17:39,738 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-19 21:17:39,740 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-20 18:31:28,820 [KlippyGtk.py:Dialog()] - Showing dialog KlipperScreen (width=800, height=480)
2023-11-20 18:32:52,811 [KlippyGtk.py:remove_dialog()] - Removing Dialog
2023-11-20 18:32:53,933 [screen.py:_load_panel()] - Loading panel: move
2023-11-20 18:32:54,123 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > move
2023-11-20 18:32:56,633 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 Y-25 F3000'}
2023-11-20 18:32:56,644 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-20 18:32:58,272 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 Y-25 F3000'}
2023-11-20 18:32:58,277 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-20 18:32:58,584 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 Y-25 F3000'}
2023-11-20 18:32:58,588 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-20 18:32:58,940 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 Y-25 F3000'}
2023-11-20 18:32:58,944 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-20 18:32:59,245 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 Y-25 F3000'}
2023-11-20 18:32:59,250 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-20 18:32:59,560 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 Y-25 F3000'}
2023-11-20 18:32:59,565 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-20 18:32:59,888 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 Y-25 F3000'}
2023-11-20 18:32:59,892 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-20 18:33:00,208 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 Y-25 F3000'}
2023-11-20 18:33:00,212 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-20 18:33:00,952 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 Y-25 F3000'}
2023-11-20 18:33:00,958 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-20 18:33:01,264 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 Y-25 F3000'}
2023-11-20 18:33:01,268 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-20 18:33:01,592 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 Y-25 F3000'}
2023-11-20 18:33:01,596 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-20 18:33:01,920 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 Y-25 F3000'}
2023-11-20 18:33:01,924 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-20 18:33:02,241 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 Y-25 F3000'}
2023-11-20 18:33:02,246 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-20 18:33:02,584 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 Y-25 F3000'}
2023-11-20 18:33:02,589 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-20 18:33:02,609 [screen.py:show_popup_message()] - error: Move out of range: 349.799 -16.500 5.029 [0.000]
2023-11-20 18:33:02,916 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 Y-25 F3000'}
2023-11-20 18:33:02,920 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-20 18:33:02,942 [screen.py:show_popup_message()] - error: Move out of range: 349.799 -16.500 5.029 [0.000]
2023-11-20 18:33:03,248 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 Y-25 F3000'}
2023-11-20 18:33:03,253 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-20 18:33:03,273 [screen.py:show_popup_message()] - error: Move out of range: 349.799 -16.500 5.029 [0.000]
2023-11-20 18:33:03,720 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 Y-25 F3000'}
2023-11-20 18:33:03,724 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-20 18:33:03,740 [screen.py:show_popup_message()] - error: Move out of range: 349.799 -16.500 5.029 [0.000]
2023-11-20 18:33:04,029 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 Y-25 F3000'}
2023-11-20 18:33:04,035 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-20 18:33:04,066 [screen.py:show_popup_message()] - error: Move out of range: 349.799 -16.500 5.029 [0.000]
2023-11-20 18:33:06,480 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 X-25 F3000'}
2023-11-20 18:33:06,486 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-20 18:33:06,819 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 X-25 F3000'}
2023-11-20 18:33:06,823 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-20 18:33:07,120 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 X-25 F3000'}
2023-11-20 18:33:07,127 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-20 18:33:07,448 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 X-25 F3000'}
2023-11-20 18:33:07,452 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-20 18:33:07,739 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 X-25 F3000'}
2023-11-20 18:33:07,743 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-20 18:33:10,697 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 X-25 F3000'}
2023-11-20 18:33:10,704 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-20 18:33:11,024 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 X-25 F3000'}
2023-11-20 18:33:11,028 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-11-20 18:33:14,120 [screen.py:_menu_go_back()] - #### Menu go back
2023-11-20 18:33:14,203 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-20 18:33:16,969 [main_menu.py:toggle_visibility()] - Graph show False: extruder
2023-11-20 18:33:21,216 [main_menu.py:verify_max_temp()] - 220/350
2023-11-20 18:33:21,217 [KlippyWebsocket.py:set_tool_temp()] - Sending set_tool_temp: M104 T0 S220
2023-11-20 18:40:44,653 [files.py:_callback()] - Error in getting metadata for .thumbs/[c]_Diffuser (2)-32x32.png. Retrying in 6 seconds
2023-11-20 18:40:44,660 [files.py:_callback()] - Error in getting metadata for .thumbs/[c]_Diffuser (2)-400x300.png. Retrying in 6 seconds
2023-11-20 18:40:44,844 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-11-20 18:40:44,844 [printer.py:change_state()] - Adding callback for state: printing
2023-11-20 18:40:44,871 [screen.py:_load_panel()] - Loading panel: job_status
2023-11-20 18:40:45,126 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-11-20 18:40:45,138 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-11-20 18:40:45,160 [job_status.py:update_file_metadata()] - Update Metadata. File: [c]_Diffuser (2).gcode Size: 553200
2023-11-20 18:40:45,176 [job_status.py:show_file_thumbnail()] - [c]_Diffuser (2).gcode
2023-11-20 19:14:22,358 [job_status.py:set_state()] - Changing job_status state from 'printing' to 'complete'
2023-11-20 19:14:28,090 [printer.py:change_state()] - Changing state from 'printing' to 'ready'
2023-11-20 19:14:28,090 [printer.py:change_state()] - Adding callback for state: ready
2023-11-20 19:33:21,982 [screen.py:show_screensaver()] - Showing Screensaver
--------------------KlipperScreen Log Start--------------------
Git Version: v0.3.6-65-g4a14962
2023-11-20 21:17:23,804 [screen.py:main()] - Python version: 3.9
2023-11-20 21:17:23,807 [screen.py:main()] - KlipperScreen version: v0.3.6-65-g4a14962
2023-11-20 21:17:23,827 [functions.py:detect_desktop_environment()] - Error:
'XDG_CURRENT_DESKTOP'

Traceback (most recent call last):
  File "/home/biqu/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.9/os.py", line 679, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
Traceback (most recent call last):
  File "/home/biqu/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.9/os.py", line 679, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
2023-11-20 21:17:24,159 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-11-20 21:17:24,162 [config.py:__init__()] - Config path location: /home/biqu/printer_data/config/KlipperScreen.conf
2023-11-20 21:17:24,199 [config.py:log_config()] -  ===== Config File =====

=======================
2023-11-20 21:17:24,203 [config.py:__init__()] - ====== Saved Def ======

[main]
print_sort_dir = date_asc

[graph Printer]
extruder = False

=======================
2023-11-20 21:17:24,204 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-11-20 21:17:24,307 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-11-20 21:17:24,308 [config.py:install_language()] - Using system lang
2023-11-20 21:17:24,309 [config.py:install_language()] - Using lang en
2023-11-20 21:17:24,338 [screen.py:__init__()] - Screen resolution: 800x480
2023-11-20 21:17:24,342 [KlippyGtk.py:__init__()] - Font size: 16.6 (medium)
2023-11-20 21:17:25,956 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-11-20 21:17:25,974 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-11-20 21:17:25,990 [screen.py:initial_connection()] - Default printer: None
2023-11-20 21:17:25,991 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-11-20 21:17:25,991 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-11-20 21:17:26,087 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-20 21:17:26,110 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-11-20 21:17:26,150 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-20 21:17:26,179 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-11-20 21:17:26,183 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-11-20 21:17:26,201 [_logging.py:info()] - Websocket connected
2023-11-20 21:17:26,202 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-11-20 21:17:26,551 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-20 21:17:26,574 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-20 21:17:26,576 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'update_manager', 'authorization', 'history'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-20 21:17:26,599 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-20 21:17:26,602 [printer.py:configure_cameras()] - Cameras: []
2023-11-20 21:17:26,602 [screen.py:init_printer()] - Klipper not connected
2023-11-20 21:17:30,219 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-20 21:17:30,238 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-20 21:17:30,240 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'update_manager', 'authorization', 'history'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-20 21:17:30,259 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-20 21:17:30,261 [printer.py:configure_cameras()] - Cameras: []
2023-11-20 21:17:30,262 [screen.py:init_printer()] - Klipper not connected
2023-11-20 21:17:33,226 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-20 21:17:33,252 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-20 21:17:33,256 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'update_manager', 'authorization', 'history'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-20 21:17:33,288 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-20 21:17:33,292 [printer.py:configure_cameras()] - Cameras: []
2023-11-20 21:17:33,331 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-20 21:17:33,373 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-20 21:17:33,378 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'skew_correction': {}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.66', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.83', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'bed_mesh default': {'version': '1', 'points': '\n0.002500, 0.009375, 0.021250, -0.023750, -0.048125\n-0.006250, -0.013125, -0.060625, -0.024375, -0.038125\n-0.049375, -0.081250, -0.078750, -0.080000, -0.091875', 'x_count': '5', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '35.0', 'max_x': '306.56', 'min_y': '29.700000000000003', 'max_y': '110.08'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[0.0025, 0.009375, 0.02125, -0.02375, -0.048125], [-0.00625, -0.013125, -0.060625, -0.024375, -0.038125], [-0.049375, -0.08125, -0.07875, -0.08, -0.091875]], 'min_x': 35.0, 'max_x': 306.56, 'min_y': 29.700000000000003, 'max_y': 110.08, 'x_count': 5, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.66, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.83, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-20 21:17:33,383 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-11-20 21:17:33,383 [printer.py:reinit()] - # Extruders: 1
2023-11-20 21:17:33,384 [printer.py:reinit()] - # Temperature devices: 5
2023-11-20 21:17:33,384 [printer.py:reinit()] - # Fans: 2
2023-11-20 21:17:33,385 [printer.py:reinit()] - # Output pins: 1
2023-11-20 21:17:33,385 [printer.py:reinit()] - # Leds: 0
2023-11-20 21:17:33,412 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-20 21:17:33,416 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-20 21:17:33,697 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-11-20 21:17:33,723 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-20 21:17:33,725 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-11-20 21:17:33,726 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-20 21:17:33,727 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-20 21:17:33,728 [screen.py:init_printer()] - Printer initialized
2023-11-20 21:17:33,730 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-20 21:17:33,730 [printer.py:change_state()] - Adding callback for state: startup
2023-11-20 21:17:35,871 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-20 21:17:35,871 [printer.py:change_state()] - Adding callback for state: ready
2023-11-20 21:17:35,877 [screen.py:_load_panel()] - Loading panel: main_menu
2023-11-20 21:17:36,010 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-20 21:17:36,023 [main_menu.py:add_device()] - Adding device: extruder
2023-11-20 21:17:36,033 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-20 21:17:36,044 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-11-20 21:17:36,054 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-11-20 21:17:36,064 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-11-20 21:17:36,074 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-11-20 21:17:36,143 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-20 21:17:36,146 [main_menu.py:update_graph_visibility()] - Could not create graph tempstore: []
2023-11-20 21:17:39,222 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-20 21:17:39,250 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-11-20 21:17:39,273 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-20 21:17:39,275 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-23 19:07:43,492 [files.py:_callback()] - Error in getting metadata for .thumbs/front_left_z_motor_mount (2)-32x32.png. Retrying in 6 seconds
2023-11-23 19:07:43,495 [files.py:_callback()] - Error in getting metadata for .thumbs/front_left_z_motor_mount (2)-400x300.png. Retrying in 6 seconds
2023-11-23 19:12:28,171 [KlippyGtk.py:Dialog()] - Showing dialog KlipperScreen (width=800, height=480)
2023-11-23 19:12:28,394 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-11-23 19:12:28,395 [printer.py:change_state()] - Adding callback for state: printing
2023-11-23 19:12:28,439 [KlippyGtk.py:remove_dialog()] - Removing Dialog
2023-11-23 19:12:28,446 [screen.py:_load_panel()] - Loading panel: job_status
2023-11-23 19:12:28,731 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-11-23 19:12:28,743 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-11-23 19:12:28,770 [job_status.py:update_file_metadata()] - Update Metadata. File: front_left_z_motor_mount (2).gcode Size: 9095362
2023-11-23 19:12:28,785 [job_status.py:show_file_thumbnail()] - front_left_z_motor_mount (2).gcode
2023-11-23 19:56:28,108 [screen.py:show_screensaver()] - Showing Screensaver
2023-11-24 01:24:39,012 [screen.py:close_screensaver()] - Closing Screensaver
2023-11-24 01:24:39,054 [screen.py:wake_screen()] - Screen wake up
2023-11-24 01:24:39,108 [job_status.py:set_state()] - Changing job_status state from 'printing' to 'complete'
2023-11-24 01:24:45,018 [printer.py:change_state()] - Changing state from 'printing' to 'ready'
2023-11-24 01:24:45,018 [printer.py:change_state()] - Adding callback for state: ready
2023-11-24 02:24:39,109 [screen.py:show_screensaver()] - Showing Screensaver
2023-11-24 06:31:56,911 [files.py:_callback()] - Error in getting metadata for .thumbs/inlet_skirt_corner (2)-32x32.png. Retrying in 6 seconds
2023-11-24 06:31:56,916 [files.py:_callback()] - Error in getting metadata for .thumbs/inlet_skirt_corner (2)-400x300.png. Retrying in 6 seconds
2023-11-24 06:31:57,095 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-11-24 06:31:57,096 [printer.py:change_state()] - Adding callback for state: printing
2023-11-24 06:31:57,107 [job_status.py:set_state()] - Changing job_status state from 'complete' to 'printing'
2023-11-24 06:31:57,110 [job_status.py:update_file_metadata()] - Update Metadata. File: inlet_skirt_corner (2).gcode Size: 9589676
2023-11-24 06:31:57,121 [job_status.py:show_file_thumbnail()] - inlet_skirt_corner (2).gcode
2023-11-24 06:31:57,134 [screen.py:close_screensaver()] - Closing Screensaver
2023-11-24 06:31:57,164 [screen.py:wake_screen()] - Screen wake up
2023-11-24 06:31:57,221 [screen.py:show_panel()] - Reinitializing panel
2023-11-24 06:31:57,452 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-11-24 06:31:57,463 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-11-24 06:31:57,479 [job_status.py:update_file_metadata()] - Update Metadata. File: inlet_skirt_corner (2).gcode Size: 9589676
2023-11-24 06:31:57,489 [job_status.py:show_file_thumbnail()] - inlet_skirt_corner (2).gcode
2023-11-24 07:31:58,107 [screen.py:show_screensaver()] - Showing Screensaver
2023-11-24 14:49:25,719 [screen.py:close_screensaver()] - Closing Screensaver
2023-11-24 14:49:25,747 [screen.py:wake_screen()] - Screen wake up
2023-11-24 14:49:25,801 [job_status.py:set_state()] - Changing job_status state from 'printing' to 'complete'
2023-11-24 14:49:31,723 [printer.py:change_state()] - Changing state from 'printing' to 'ready'
2023-11-24 14:49:31,723 [printer.py:change_state()] - Adding callback for state: ready
2023-11-24 15:49:26,109 [screen.py:show_screensaver()] - Showing Screensaver
2023-11-24 19:19:57,888 [screen.py:close_screensaver()] - Closing Screensaver
2023-11-24 19:19:57,928 [screen.py:wake_screen()] - Screen wake up
2023-11-24 19:25:31,449 [files.py:_callback()] - Error in getting metadata for .thumbs/handle_a_x2-32x32.png. Retrying in 6 seconds
2023-11-24 19:25:31,458 [files.py:_callback()] - Error in getting metadata for .thumbs/handle_a_x2-400x300.png. Retrying in 6 seconds
2023-11-24 19:25:31,601 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-11-24 19:25:31,603 [printer.py:change_state()] - Adding callback for state: printing
2023-11-24 19:25:31,622 [job_status.py:set_state()] - Changing job_status state from 'complete' to 'printing'
2023-11-24 19:25:31,639 [job_status.py:update_file_metadata()] - Update Metadata. File: handle_a_x2.gcode Size: 2233731
2023-11-24 19:25:31,650 [job_status.py:show_file_thumbnail()] - handle_a_x2.gcode
2023-11-24 19:25:31,721 [screen.py:show_panel()] - Reinitializing panel
2023-11-24 19:25:31,957 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-11-24 19:25:31,969 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-11-24 19:25:31,985 [job_status.py:update_file_metadata()] - Update Metadata. File: handle_a_x2.gcode Size: 2233731
2023-11-24 19:25:31,995 [job_status.py:show_file_thumbnail()] - handle_a_x2.gcode
2023-11-24 20:19:58,108 [screen.py:show_screensaver()] - Showing Screensaver
2023-11-24 21:06:51,966 [screen.py:close_screensaver()] - Closing Screensaver
2023-11-24 21:06:51,994 [screen.py:wake_screen()] - Screen wake up
2023-11-24 21:06:52,048 [job_status.py:set_state()] - Changing job_status state from 'printing' to 'complete'
2023-11-24 21:06:57,978 [printer.py:change_state()] - Changing state from 'printing' to 'ready'
2023-11-24 21:06:57,979 [printer.py:change_state()] - Adding callback for state: ready
2023-11-24 22:06:52,110 [screen.py:show_screensaver()] - Showing Screensaver
--------------------KlipperScreen Log Start--------------------
Git Version: v0.3.6-65-g4a14962
2023-11-24 22:17:19,415 [screen.py:main()] - Python version: 3.9
2023-11-24 22:17:19,416 [screen.py:main()] - KlipperScreen version: v0.3.6-65-g4a14962
2023-11-24 22:17:19,447 [functions.py:detect_desktop_environment()] - Error:
'XDG_CURRENT_DESKTOP'

Traceback (most recent call last):
  File "/home/biqu/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.9/os.py", line 679, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
Traceback (most recent call last):
  File "/home/biqu/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.9/os.py", line 679, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
2023-11-24 22:17:20,059 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-11-24 22:17:20,062 [config.py:__init__()] - Config path location: /home/biqu/printer_data/config/KlipperScreen.conf
2023-11-24 22:17:20,124 [config.py:log_config()] -  ===== Config File =====

=======================
2023-11-24 22:17:20,128 [config.py:__init__()] - ====== Saved Def ======

[main]
print_sort_dir = date_asc

[graph Printer]
extruder = False

=======================
2023-11-24 22:17:20,129 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-11-24 22:17:20,429 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-11-24 22:17:20,430 [config.py:install_language()] - Using system lang
2023-11-24 22:17:20,431 [config.py:install_language()] - Using lang en
2023-11-24 22:17:20,488 [screen.py:__init__()] - Screen resolution: 800x480
2023-11-24 22:17:20,495 [KlippyGtk.py:__init__()] - Font size: 16.6 (medium)
2023-11-24 22:17:22,666 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-11-24 22:17:22,683 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-11-24 22:17:22,698 [screen.py:initial_connection()] - Default printer: None
2023-11-24 22:17:22,699 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-11-24 22:17:22,700 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-11-24 22:17:22,810 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-24 22:17:22,838 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-11-24 22:17:22,882 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-24 22:17:22,906 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-11-24 22:17:22,909 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-11-24 22:17:22,925 [_logging.py:info()] - Websocket connected
2023-11-24 22:17:22,926 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-11-24 22:17:23,243 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-24 22:17:23,264 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-24 22:17:23,267 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'update_manager', 'history', 'authorization'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-24 22:17:23,288 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-24 22:17:23,290 [printer.py:configure_cameras()] - Cameras: []
2023-11-24 22:17:23,291 [screen.py:init_printer()] - Klipper not connected
2023-11-24 22:17:26,451 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-24 22:17:26,477 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-24 22:17:26,481 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'update_manager', 'history', 'authorization'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-24 22:17:26,503 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-24 22:17:26,507 [printer.py:configure_cameras()] - Cameras: []
2023-11-24 22:17:26,508 [screen.py:init_printer()] - Klipper not connected
2023-11-24 22:17:29,447 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-24 22:17:29,469 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-24 22:17:29,471 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'update_manager', 'history', 'authorization'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-24 22:17:29,493 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-24 22:17:29,495 [printer.py:configure_cameras()] - Cameras: []
2023-11-24 22:17:29,496 [screen.py:init_printer()] - Klipper not connected
2023-11-24 22:17:32,453 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-24 22:17:32,475 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-24 22:17:32,479 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'update_manager', 'history', 'authorization'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-24 22:17:32,501 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-24 22:17:32,505 [printer.py:configure_cameras()] - Cameras: []
2023-11-24 22:17:32,551 [KlippyRest.py:_do_request()] - 404 Client Error>>Not Found for url>>http://127.0.0.1:7125/printer/info
2023-11-24 22:17:35,453 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-24 22:17:35,474 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-24 22:17:35,476 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'update_manager', 'history', 'authorization'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-24 22:17:35,496 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-24 22:17:35,498 [printer.py:configure_cameras()] - Cameras: []
2023-11-24 22:17:35,521 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-24 22:17:35,572 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-24 22:17:35,577 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'skew_correction': {}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.66', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.83', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'bed_mesh default': {'version': '1', 'points': '\n0.002500, 0.009375, 0.021250, -0.023750, -0.048125\n-0.006250, -0.013125, -0.060625, -0.024375, -0.038125\n-0.049375, -0.081250, -0.078750, -0.080000, -0.091875', 'x_count': '5', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '35.0', 'max_x': '306.56', 'min_y': '29.700000000000003', 'max_y': '110.08'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[0.0025, 0.009375, 0.02125, -0.02375, -0.048125], [-0.00625, -0.013125, -0.060625, -0.024375, -0.038125], [-0.049375, -0.08125, -0.07875, -0.08, -0.091875]], 'min_x': 35.0, 'max_x': 306.56, 'min_y': 29.700000000000003, 'max_y': 110.08, 'x_count': 5, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.66, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.83, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-24 22:17:35,583 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-11-24 22:17:35,583 [printer.py:reinit()] - # Extruders: 1
2023-11-24 22:17:35,583 [printer.py:reinit()] - # Temperature devices: 5
2023-11-24 22:17:35,584 [printer.py:reinit()] - # Fans: 2
2023-11-24 22:17:35,584 [printer.py:reinit()] - # Output pins: 1
2023-11-24 22:17:35,584 [printer.py:reinit()] - # Leds: 0
2023-11-24 22:17:35,617 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-24 22:17:35,621 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-24 22:17:35,897 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-11-24 22:17:35,928 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-24 22:17:35,930 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-11-24 22:17:35,931 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-24 22:17:35,932 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-24 22:17:35,933 [screen.py:init_printer()] - Printer initialized
2023-11-24 22:17:35,934 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-24 22:17:35,935 [printer.py:change_state()] - Adding callback for state: startup
2023-11-24 22:17:36,233 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-24 22:17:36,234 [printer.py:change_state()] - Adding callback for state: ready
2023-11-24 22:17:36,239 [screen.py:_load_panel()] - Loading panel: main_menu
2023-11-24 22:17:36,412 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-24 22:17:36,427 [main_menu.py:add_device()] - Adding device: extruder
2023-11-24 22:17:36,440 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-24 22:17:36,452 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-11-24 22:17:36,462 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-11-24 22:17:36,472 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-11-24 22:17:36,483 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-11-24 22:17:36,551 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-24 22:17:36,554 [main_menu.py:update_graph_visibility()] - Could not create graph tempstore: []
2023-11-24 22:17:41,458 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-24 22:17:41,490 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-11-24 22:17:41,530 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-24 22:17:41,532 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-25 12:05:25,661 [files.py:_callback()] - Error in getting metadata for .thumbs/Califlower v13_ABS_1h43m-350x350.png. Retrying in 6 seconds
2023-11-25 12:05:25,666 [files.py:_callback()] - Error in getting metadata for .thumbs/Califlower v13_ABS_1h43m-32x32.png. Retrying in 6 seconds
2023-11-25 12:05:25,811 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-11-25 12:05:25,811 [printer.py:change_state()] - Adding callback for state: printing
2023-11-25 12:05:25,851 [screen.py:_load_panel()] - Loading panel: job_status
2023-11-25 12:05:26,079 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-11-25 12:05:26,090 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-11-25 12:05:26,127 [job_status.py:update_file_metadata()] - Update Metadata. File: Califlower v13_ABS_1h43m.gcode Size: 5255614
2023-11-25 12:05:26,142 [job_status.py:show_file_thumbnail()] - Califlower v13_ABS_1h43m.gcode
2023-11-25 13:17:27,561 [screen.py:show_screensaver()] - Showing Screensaver
2023-11-25 14:05:17,754 [screen.py:close_screensaver()] - Closing Screensaver
2023-11-25 14:05:17,783 [screen.py:wake_screen()] - Screen wake up
2023-11-25 14:05:17,837 [job_status.py:set_state()] - Changing job_status state from 'printing' to 'complete'
2023-11-25 14:05:20,761 [printer.py:change_state()] - Changing state from 'printing' to 'ready'
2023-11-25 14:05:20,762 [printer.py:change_state()] - Adding callback for state: ready
2023-11-25 14:45:53,770 [printer.py:change_state()] - Changing state from 'ready' to 'disconnected'
2023-11-25 14:45:53,771 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-25 14:45:53,774 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-25 14:45:53,779 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 14:45:53,886 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-25 14:45:57,591 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 14:45:57,609 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 14:45:57,611 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'update_manager', 'history', 'authorization'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 3, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-25 14:45:57,627 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-25 14:45:57,629 [printer.py:configure_cameras()] - Cameras: []
2023-11-25 14:45:57,649 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-25 14:45:57,683 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-25 14:45:57,687 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.66', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.83', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'skew_correction': {}, 'bed_mesh default': {'version': '1', 'points': '\n0.002500, 0.009375, 0.021250, -0.023750, -0.048125\n-0.006250, -0.013125, -0.060625, -0.024375, -0.038125\n-0.049375, -0.081250, -0.078750, -0.080000, -0.091875', 'x_count': '5', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '35.0', 'max_x': '306.56', 'min_y': '29.700000000000003', 'max_y': '110.08'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[0.0025, 0.009375, 0.02125, -0.02375, -0.048125], [-0.00625, -0.013125, -0.060625, -0.024375, -0.038125], [-0.049375, -0.08125, -0.07875, -0.08, -0.091875]], 'min_x': 35.0, 'max_x': 306.56, 'min_y': 29.700000000000003, 'max_y': 110.08, 'x_count': 5, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.66, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.83, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-25 14:45:57,694 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-11-25 14:45:57,695 [printer.py:reinit()] - # Extruders: 1
2023-11-25 14:45:57,695 [printer.py:reinit()] - # Temperature devices: 5
2023-11-25 14:45:57,696 [printer.py:reinit()] - # Fans: 2
2023-11-25 14:45:57,696 [printer.py:reinit()] - # Output pins: 1
2023-11-25 14:45:57,696 [printer.py:reinit()] - # Leds: 0
2023-11-25 14:45:57,720 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-25 14:45:57,723 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-25 14:45:58,013 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-11-25 14:45:58,067 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-25 14:45:58,077 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-11-25 14:45:58,100 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-25 14:45:58,103 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-25 14:45:58,104 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-25 14:45:58,104 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-25 14:45:58,105 [screen.py:init_printer()] - Printer initialized
2023-11-25 14:45:58,106 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-25 14:45:58,107 [printer.py:change_state()] - Adding callback for state: startup
2023-11-25 14:45:58,679 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-25 14:45:58,679 [printer.py:change_state()] - Adding callback for state: ready
2023-11-25 14:45:58,685 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 14:45:58,803 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-25 14:45:58,817 [main_menu.py:add_device()] - Adding device: extruder
2023-11-25 14:45:58,827 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-25 14:45:58,837 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-11-25 14:45:58,847 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-11-25 14:45:58,857 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-11-25 14:45:58,867 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-11-25 14:45:58,944 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-25 14:46:23,166 [KlippyGtk.py:Dialog()] - Showing dialog KlipperScreen (width=800, height=480)
2023-11-25 14:52:07,245 [printer.py:change_state()] - Changing state from 'ready' to 'disconnected'
2023-11-25 14:52:07,246 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-25 14:52:07,249 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-25 14:52:07,259 [KlippyGtk.py:remove_dialog()] - Removing Dialog
2023-11-25 14:52:07,261 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 14:52:07,385 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-25 14:52:10,579 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 14:52:10,597 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 14:52:10,599 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'update_manager', 'history', 'authorization'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 3, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-25 14:52:10,616 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-25 14:52:10,618 [printer.py:configure_cameras()] - Cameras: []
2023-11-25 14:52:10,638 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-25 14:52:10,672 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-25 14:52:10,676 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.74', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.93', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'skew_correction': {}, 'bed_mesh default': {'version': '1', 'points': '\n0.002500, 0.009375, 0.021250, -0.023750, -0.048125\n-0.006250, -0.013125, -0.060625, -0.024375, -0.038125\n-0.049375, -0.081250, -0.078750, -0.080000, -0.091875', 'x_count': '5', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '35.0', 'max_x': '306.56', 'min_y': '29.700000000000003', 'max_y': '110.08'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[0.0025, 0.009375, 0.02125, -0.02375, -0.048125], [-0.00625, -0.013125, -0.060625, -0.024375, -0.038125], [-0.049375, -0.08125, -0.07875, -0.08, -0.091875]], 'min_x': 35.0, 'max_x': 306.56, 'min_y': 29.700000000000003, 'max_y': 110.08, 'x_count': 5, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.74, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.93, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-25 14:52:10,683 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-11-25 14:52:10,683 [printer.py:reinit()] - # Extruders: 1
2023-11-25 14:52:10,684 [printer.py:reinit()] - # Temperature devices: 5
2023-11-25 14:52:10,684 [printer.py:reinit()] - # Fans: 2
2023-11-25 14:52:10,684 [printer.py:reinit()] - # Output pins: 1
2023-11-25 14:52:10,684 [printer.py:reinit()] - # Leds: 0
2023-11-25 14:52:10,706 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-25 14:52:10,709 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-25 14:52:11,063 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-11-25 14:52:11,114 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-25 14:52:11,123 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-11-25 14:52:11,147 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-25 14:52:11,150 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-25 14:52:11,150 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-25 14:52:11,151 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-25 14:52:11,152 [screen.py:init_printer()] - Printer initialized
2023-11-25 14:52:11,153 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-25 14:52:11,154 [printer.py:change_state()] - Adding callback for state: startup
2023-11-25 14:52:12,168 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-25 14:52:12,168 [printer.py:change_state()] - Adding callback for state: ready
2023-11-25 14:52:12,176 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 14:52:12,294 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-25 14:52:12,307 [main_menu.py:add_device()] - Adding device: extruder
2023-11-25 14:52:12,317 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-25 14:52:12,327 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-11-25 14:52:12,338 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-11-25 14:52:12,348 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-11-25 14:52:12,357 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-11-25 14:52:12,432 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-25 14:52:47,112 [screen.py:show_popup_message()] - error: // skew_correction:  Load failed, unknown profile [my_skew_profile]
2023-11-25 14:52:47,306 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-11-25 14:52:47,307 [printer.py:change_state()] - Adding callback for state: printing
2023-11-25 14:52:47,341 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 14:52:47,546 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-11-25 14:52:47,557 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-11-25 14:52:47,572 [job_status.py:update_file_metadata()] - Update Metadata. File: Califlower v13_ABS_1h43m.gcode Size: 5213336
2023-11-25 14:52:47,581 [job_status.py:show_file_thumbnail()] - Califlower v13_ABS_1h43m.gcode
2023-11-25 14:52:48,099 [files.py:add_file()] - File already exists: Califlower v13_ABS_1h43m.gcode
2023-11-25 14:54:09,529 [printer.py:change_state()] - Changing state from 'printing' to 'shutdown'
2023-11-25 14:54:09,530 [printer.py:change_state()] - Adding callback for state: shutdown
2023-11-25 14:54:09,603 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 14:54:09,688 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-25 14:54:12,793 [printer.py:change_state()] - Changing state from 'shutdown' to 'disconnected'
2023-11-25 14:54:12,793 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-25 14:54:12,795 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-25 14:54:12,797 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 14:54:12,866 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-25 14:54:16,586 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 14:54:16,606 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 14:54:16,608 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'update_manager', 'history', 'authorization'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 3, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-25 14:54:16,625 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-25 14:54:16,626 [printer.py:configure_cameras()] - Cameras: []
2023-11-25 14:54:16,646 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-25 14:54:16,681 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-25 14:54:16,685 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.74', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.93', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'skew_correction': {}, 'bed_mesh default': {'version': '1', 'points': '\n0.002500, 0.009375, 0.021250, -0.023750, -0.048125\n-0.006250, -0.013125, -0.060625, -0.024375, -0.038125\n-0.049375, -0.081250, -0.078750, -0.080000, -0.091875', 'x_count': '5', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '35.0', 'max_x': '306.56', 'min_y': '29.700000000000003', 'max_y': '110.08'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[0.0025, 0.009375, 0.02125, -0.02375, -0.048125], [-0.00625, -0.013125, -0.060625, -0.024375, -0.038125], [-0.049375, -0.08125, -0.07875, -0.08, -0.091875]], 'min_x': 35.0, 'max_x': 306.56, 'min_y': 29.700000000000003, 'max_y': 110.08, 'x_count': 5, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.74, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.93, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-25 14:54:16,692 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-11-25 14:54:16,692 [printer.py:reinit()] - # Extruders: 1
2023-11-25 14:54:16,692 [printer.py:reinit()] - # Temperature devices: 5
2023-11-25 14:54:16,692 [printer.py:reinit()] - # Fans: 2
2023-11-25 14:54:16,693 [printer.py:reinit()] - # Output pins: 1
2023-11-25 14:54:16,693 [printer.py:reinit()] - # Leds: 0
2023-11-25 14:54:16,717 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-25 14:54:16,720 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-25 14:54:17,005 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-11-25 14:54:17,058 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-25 14:54:17,068 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-11-25 14:54:17,088 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-25 14:54:17,091 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-25 14:54:17,091 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-25 14:54:17,092 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-25 14:54:17,093 [screen.py:init_printer()] - Printer initialized
2023-11-25 14:54:17,094 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-25 14:54:17,094 [printer.py:change_state()] - Adding callback for state: startup
2023-11-25 14:54:17,193 [printer.py:change_state()] - Changing state from 'startup' to 'error'
2023-11-25 14:54:17,194 [printer.py:change_state()] - Adding callback for state: error
2023-11-25 14:54:17,199 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 14:54:17,266 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-25 14:54:23,902 [printer.py:change_state()] - Changing state from 'error' to 'disconnected'
2023-11-25 14:54:23,903 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-25 14:54:23,904 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-25 14:54:23,907 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 14:54:24,001 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-25 14:54:27,584 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 14:54:27,608 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 14:54:27,610 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'update_manager', 'history', 'authorization'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 3, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-25 14:54:27,635 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-25 14:54:27,637 [printer.py:configure_cameras()] - Cameras: []
2023-11-25 14:54:27,664 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-25 14:54:27,716 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-25 14:54:27,721 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.74', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.93', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'skew_correction': {}, 'bed_mesh default': {'version': '1', 'points': '\n0.002500, 0.009375, 0.021250, -0.023750, -0.048125\n-0.006250, -0.013125, -0.060625, -0.024375, -0.038125\n-0.049375, -0.081250, -0.078750, -0.080000, -0.091875', 'x_count': '5', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '35.0', 'max_x': '306.56', 'min_y': '29.700000000000003', 'max_y': '110.08'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[0.0025, 0.009375, 0.02125, -0.02375, -0.048125], [-0.00625, -0.013125, -0.060625, -0.024375, -0.038125], [-0.049375, -0.08125, -0.07875, -0.08, -0.091875]], 'min_x': 35.0, 'max_x': 306.56, 'min_y': 29.700000000000003, 'max_y': 110.08, 'x_count': 5, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.74, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.93, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-25 14:54:27,729 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-11-25 14:54:27,729 [printer.py:reinit()] - # Extruders: 1
2023-11-25 14:54:27,729 [printer.py:reinit()] - # Temperature devices: 5
2023-11-25 14:54:27,730 [printer.py:reinit()] - # Fans: 2
2023-11-25 14:54:27,730 [printer.py:reinit()] - # Output pins: 1
2023-11-25 14:54:27,731 [printer.py:reinit()] - # Leds: 0
2023-11-25 14:54:27,764 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-25 14:54:27,767 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-25 14:54:28,034 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-11-25 14:54:28,085 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-25 14:54:28,094 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-11-25 14:54:28,114 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-25 14:54:28,116 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-25 14:54:28,117 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-25 14:54:28,117 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-25 14:54:28,118 [screen.py:init_printer()] - Printer initialized
2023-11-25 14:54:28,120 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-25 14:54:28,120 [printer.py:change_state()] - Adding callback for state: startup
2023-11-25 14:54:28,955 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-25 14:54:28,956 [printer.py:change_state()] - Adding callback for state: ready
2023-11-25 14:54:28,962 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 14:54:29,086 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-25 14:54:29,100 [main_menu.py:add_device()] - Adding device: extruder
2023-11-25 14:54:29,110 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-25 14:54:29,120 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-11-25 14:54:29,130 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-11-25 14:54:29,140 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-11-25 14:54:29,150 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-11-25 14:54:29,226 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-25 14:54:41,601 [KlippyGtk.py:remove_dialog()] - Cannot remove dialog <Gtk.Dialog object at 0xffffa879d840 (GtkDialog at 0x3413c8c0)>
2023-11-25 14:54:41,630 [KlippyGtk.py:Dialog()] - Showing dialog KlipperScreen (width=800, height=480)
2023-11-25 14:54:45,550 [printer.py:change_state()] - Changing state from 'ready' to 'disconnected'
2023-11-25 14:54:45,550 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-25 14:54:45,552 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-25 14:54:45,558 [KlippyGtk.py:remove_dialog()] - Removing Dialog
2023-11-25 14:54:45,559 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 14:54:45,628 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-25 14:54:48,586 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 14:54:48,609 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 14:54:48,611 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'update_manager', 'history', 'authorization'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 3, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-25 14:54:48,633 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-25 14:54:48,635 [printer.py:configure_cameras()] - Cameras: []
2023-11-25 14:54:48,660 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-25 14:54:48,701 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-25 14:54:48,706 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.74', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.93', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'skew_correction': {}, 'bed_mesh default': {'version': '1', 'points': '\n0.002500, 0.009375, 0.021250, -0.023750, -0.048125\n-0.006250, -0.013125, -0.060625, -0.024375, -0.038125\n-0.049375, -0.081250, -0.078750, -0.080000, -0.091875', 'x_count': '5', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '35.0', 'max_x': '306.56', 'min_y': '29.700000000000003', 'max_y': '110.08'}, 'skew_correction my_skew_profile': {'xy_skew': '0.006789896456448232', 'xz_skew': '0.0', 'yz_skew': '0.0'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[0.0025, 0.009375, 0.02125, -0.02375, -0.048125], [-0.00625, -0.013125, -0.060625, -0.024375, -0.038125], [-0.049375, -0.08125, -0.07875, -0.08, -0.091875]], 'min_x': 35.0, 'max_x': 306.56, 'min_y': 29.700000000000003, 'max_y': 110.08, 'x_count': 5, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.74, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.93, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'skew_correction my_skew_profile': {'xy_skew': 0.006789896456448232, 'xz_skew': 0.0, 'yz_skew': 0.0}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-25 14:54:48,713 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-11-25 14:54:48,714 [printer.py:reinit()] - # Extruders: 1
2023-11-25 14:54:48,714 [printer.py:reinit()] - # Temperature devices: 5
2023-11-25 14:54:48,715 [printer.py:reinit()] - # Fans: 2
2023-11-25 14:54:48,715 [printer.py:reinit()] - # Output pins: 1
2023-11-25 14:54:48,715 [printer.py:reinit()] - # Leds: 0
2023-11-25 14:54:48,785 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-25 14:54:48,788 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-25 14:54:49,021 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-11-25 14:54:49,074 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-25 14:54:49,084 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-11-25 14:54:49,104 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-25 14:54:49,106 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-25 14:54:49,107 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-25 14:54:49,108 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-25 14:54:49,109 [screen.py:init_printer()] - Printer initialized
2023-11-25 14:54:49,110 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-25 14:54:49,110 [printer.py:change_state()] - Adding callback for state: startup
2023-11-25 14:54:50,444 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-25 14:54:50,445 [printer.py:change_state()] - Adding callback for state: ready
2023-11-25 14:54:50,452 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 14:54:50,570 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-25 14:54:50,584 [main_menu.py:add_device()] - Adding device: extruder
2023-11-25 14:54:50,594 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-25 14:54:50,605 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-11-25 14:54:50,615 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-11-25 14:54:50,625 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-11-25 14:54:50,635 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-11-25 14:54:50,707 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-25 14:54:51,546 [printer.py:change_state()] - Changing state from 'ready' to 'disconnected'
2023-11-25 14:54:51,547 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-25 14:54:51,548 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-25 14:54:51,553 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 14:54:51,656 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-25 14:54:54,584 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 14:54:54,604 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 14:54:54,606 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'update_manager', 'history', 'authorization'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 3, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-25 14:54:54,626 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-25 14:54:54,628 [printer.py:configure_cameras()] - Cameras: []
2023-11-25 14:54:54,652 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-25 14:54:54,686 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-25 14:54:54,690 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.74', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.93', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'skew_correction': {}, 'bed_mesh default': {'version': '1', 'points': '\n0.002500, 0.009375, 0.021250, -0.023750, -0.048125\n-0.006250, -0.013125, -0.060625, -0.024375, -0.038125\n-0.049375, -0.081250, -0.078750, -0.080000, -0.091875', 'x_count': '5', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '35.0', 'max_x': '306.56', 'min_y': '29.700000000000003', 'max_y': '110.08'}, 'skew_correction my_skew_profile': {'xy_skew': '0.006789896456448232', 'xz_skew': '0.0', 'yz_skew': '0.0'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[0.0025, 0.009375, 0.02125, -0.02375, -0.048125], [-0.00625, -0.013125, -0.060625, -0.024375, -0.038125], [-0.049375, -0.08125, -0.07875, -0.08, -0.091875]], 'min_x': 35.0, 'max_x': 306.56, 'min_y': 29.700000000000003, 'max_y': 110.08, 'x_count': 5, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.74, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.93, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'skew_correction my_skew_profile': {'xy_skew': 0.006789896456448232, 'xz_skew': 0.0, 'yz_skew': 0.0}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-25 14:54:54,697 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-11-25 14:54:54,697 [printer.py:reinit()] - # Extruders: 1
2023-11-25 14:54:54,698 [printer.py:reinit()] - # Temperature devices: 5
2023-11-25 14:54:54,698 [printer.py:reinit()] - # Fans: 2
2023-11-25 14:54:54,698 [printer.py:reinit()] - # Output pins: 1
2023-11-25 14:54:54,698 [printer.py:reinit()] - # Leds: 0
2023-11-25 14:54:54,722 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-25 14:54:54,725 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-25 14:54:55,009 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-11-25 14:54:55,061 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-25 14:54:55,073 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-11-25 14:54:55,104 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-25 14:54:55,107 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-25 14:54:55,108 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-25 14:54:55,108 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-25 14:54:55,109 [screen.py:init_printer()] - Printer initialized
2023-11-25 14:54:55,111 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-25 14:54:55,111 [printer.py:change_state()] - Adding callback for state: startup
2023-11-25 14:54:56,428 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-25 14:54:56,429 [printer.py:change_state()] - Adding callback for state: ready
2023-11-25 14:54:56,434 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 14:54:56,554 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-25 14:54:56,567 [main_menu.py:add_device()] - Adding device: extruder
2023-11-25 14:54:56,577 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-25 14:54:56,588 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-11-25 14:54:56,598 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-11-25 14:54:56,608 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-11-25 14:54:56,618 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-11-25 14:54:56,696 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-25 14:55:33,835 [printer.py:change_state()] - Changing state from 'ready' to 'disconnected'
2023-11-25 14:55:33,836 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-25 14:55:33,839 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-25 14:55:33,845 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 14:55:33,970 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-25 14:55:37,583 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 14:55:37,600 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 14:55:37,602 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'update_manager', 'history', 'authorization'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 3, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-25 14:55:37,620 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-25 14:55:37,622 [printer.py:configure_cameras()] - Cameras: []
2023-11-25 14:55:37,641 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-25 14:55:37,675 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-25 14:55:37,679 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.74', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.93', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'skew_correction': {}, 'bed_mesh default': {'version': '1', 'points': '\n0.002500, 0.009375, 0.021250, -0.023750, -0.048125\n-0.006250, -0.013125, -0.060625, -0.024375, -0.038125\n-0.049375, -0.081250, -0.078750, -0.080000, -0.091875', 'x_count': '5', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '35.0', 'max_x': '306.56', 'min_y': '29.700000000000003', 'max_y': '110.08'}, 'skew_correction my_skew_profile': {'xy_skew': '0.006789896456448232', 'xz_skew': '0.0', 'yz_skew': '0.0'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[0.0025, 0.009375, 0.02125, -0.02375, -0.048125], [-0.00625, -0.013125, -0.060625, -0.024375, -0.038125], [-0.049375, -0.08125, -0.07875, -0.08, -0.091875]], 'min_x': 35.0, 'max_x': 306.56, 'min_y': 29.700000000000003, 'max_y': 110.08, 'x_count': 5, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.74, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.93, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'skew_correction my_skew_profile': {'xy_skew': 0.006789896456448232, 'xz_skew': 0.0, 'yz_skew': 0.0}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-25 14:55:37,686 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-11-25 14:55:37,687 [printer.py:reinit()] - # Extruders: 1
2023-11-25 14:55:37,687 [printer.py:reinit()] - # Temperature devices: 5
2023-11-25 14:55:37,687 [printer.py:reinit()] - # Fans: 2
2023-11-25 14:55:37,688 [printer.py:reinit()] - # Output pins: 1
2023-11-25 14:55:37,688 [printer.py:reinit()] - # Leds: 0
2023-11-25 14:55:37,710 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-25 14:55:37,713 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-25 14:55:37,998 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-11-25 14:55:38,056 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-25 14:55:38,066 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-11-25 14:55:38,091 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-25 14:55:38,093 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-25 14:55:38,094 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-25 14:55:38,095 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-25 14:55:38,096 [screen.py:init_printer()] - Printer initialized
2023-11-25 14:55:38,098 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-25 14:55:38,098 [printer.py:change_state()] - Adding callback for state: startup
2023-11-25 14:55:38,665 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-25 14:55:38,666 [printer.py:change_state()] - Adding callback for state: ready
2023-11-25 14:55:38,672 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 14:55:38,791 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-25 14:55:38,805 [main_menu.py:add_device()] - Adding device: extruder
2023-11-25 14:55:38,815 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-25 14:55:38,827 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-11-25 14:55:38,837 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-11-25 14:55:38,847 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-11-25 14:55:38,857 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-11-25 14:55:38,937 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
--------------------KlipperScreen Log Start--------------------
Git Version: v0.3.6-65-g4a14962
2023-11-25 14:55:59,195 [screen.py:main()] - Python version: 3.9
2023-11-25 14:55:59,197 [screen.py:main()] - KlipperScreen version: v0.3.6-65-g4a14962
2023-11-25 14:55:59,219 [functions.py:detect_desktop_environment()] - Error:
'XDG_CURRENT_DESKTOP'

Traceback (most recent call last):
  File "/home/biqu/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.9/os.py", line 679, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
Traceback (most recent call last):
  File "/home/biqu/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.9/os.py", line 679, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
2023-11-25 14:55:59,649 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-11-25 14:55:59,653 [config.py:__init__()] - Config path location: /home/biqu/printer_data/config/KlipperScreen.conf
2023-11-25 14:55:59,701 [config.py:log_config()] -  ===== Config File =====

=======================
2023-11-25 14:55:59,706 [config.py:__init__()] - ====== Saved Def ======

[main]
print_sort_dir = date_asc

[graph Printer]
extruder = False

=======================
2023-11-25 14:55:59,708 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-11-25 14:55:59,967 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-11-25 14:55:59,967 [config.py:install_language()] - Using system lang
2023-11-25 14:55:59,969 [config.py:install_language()] - Using lang en
2023-11-25 14:56:00,030 [screen.py:__init__()] - Screen resolution: 800x480
2023-11-25 14:56:00,036 [KlippyGtk.py:__init__()] - Font size: 16.6 (medium)
2023-11-25 14:56:02,180 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-11-25 14:56:02,195 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-11-25 14:56:02,207 [screen.py:initial_connection()] - Default printer: None
2023-11-25 14:56:02,207 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-11-25 14:56:02,208 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-11-25 14:56:02,321 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-25 14:56:02,345 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-11-25 14:56:02,368 [KlippyRest.py:_do_request()] - host=127.0.0.1, port=7125>>Max retries exceeded with url>>Failed to establish a new connection>>[Errno 111] Connection refused
2023-11-25 14:56:12,406 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-11-25 14:56:12,435 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 14:56:12,461 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-11-25 14:56:12,463 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-11-25 14:56:12,480 [_logging.py:info()] - Websocket connected
2023-11-25 14:56:12,480 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-11-25 14:56:12,505 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 14:56:12,530 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 14:56:12,533 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'update_manager', 'history', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-25 14:56:12,556 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-25 14:56:12,558 [printer.py:configure_cameras()] - Cameras: []
2023-11-25 14:56:12,602 [KlippyRest.py:_do_request()] - 404 Client Error>>Not Found for url>>http://127.0.0.1:7125/printer/info
2023-11-25 14:56:15,421 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 14:56:15,441 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 14:56:15,443 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'update_manager', 'history', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-25 14:56:15,462 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-25 14:56:15,464 [printer.py:configure_cameras()] - Cameras: []
2023-11-25 14:56:15,487 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-25 14:56:15,531 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-25 14:56:15,536 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.74', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.93', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'skew_correction': {}, 'bed_mesh default': {'version': '1', 'points': '\n0.002500, 0.009375, 0.021250, -0.023750, -0.048125\n-0.006250, -0.013125, -0.060625, -0.024375, -0.038125\n-0.049375, -0.081250, -0.078750, -0.080000, -0.091875', 'x_count': '5', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '35.0', 'max_x': '306.56', 'min_y': '29.700000000000003', 'max_y': '110.08'}, 'skew_correction my_skew_profile': {'xy_skew': '0.006789896456448232', 'xz_skew': '0.0', 'yz_skew': '0.0'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[0.0025, 0.009375, 0.02125, -0.02375, -0.048125], [-0.00625, -0.013125, -0.060625, -0.024375, -0.038125], [-0.049375, -0.08125, -0.07875, -0.08, -0.091875]], 'min_x': 35.0, 'max_x': 306.56, 'min_y': 29.700000000000003, 'max_y': 110.08, 'x_count': 5, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.74, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.93, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'skew_correction my_skew_profile': {'xy_skew': 0.006789896456448232, 'xz_skew': 0.0, 'yz_skew': 0.0}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-25 14:56:15,542 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-11-25 14:56:15,542 [printer.py:reinit()] - # Extruders: 1
2023-11-25 14:56:15,543 [printer.py:reinit()] - # Temperature devices: 5
2023-11-25 14:56:15,543 [printer.py:reinit()] - # Fans: 2
2023-11-25 14:56:15,543 [printer.py:reinit()] - # Output pins: 1
2023-11-25 14:56:15,543 [printer.py:reinit()] - # Leds: 0
2023-11-25 14:56:15,570 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-25 14:56:15,573 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-25 14:56:15,875 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-11-25 14:56:15,934 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-25 14:56:15,936 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-11-25 14:56:15,938 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-25 14:56:15,938 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-25 14:56:15,940 [screen.py:init_printer()] - Printer initialized
2023-11-25 14:56:15,941 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-25 14:56:15,942 [printer.py:change_state()] - Adding callback for state: startup
2023-11-25 14:56:16,083 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-25 14:56:16,083 [printer.py:change_state()] - Adding callback for state: ready
2023-11-25 14:56:16,091 [screen.py:_load_panel()] - Loading panel: main_menu
2023-11-25 14:56:16,308 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-25 14:56:16,322 [main_menu.py:add_device()] - Adding device: extruder
2023-11-25 14:56:16,333 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-25 14:56:16,345 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-11-25 14:56:16,355 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-11-25 14:56:16,365 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-11-25 14:56:16,374 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-11-25 14:56:16,440 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-25 14:56:16,443 [main_menu.py:update_graph_visibility()] - Could not create graph tempstore: []
2023-11-25 14:56:21,418 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-25 14:56:21,445 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-11-25 14:56:21,468 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-25 14:56:21,470 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-25 14:57:13,103 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-11-25 14:57:13,104 [printer.py:change_state()] - Adding callback for state: printing
2023-11-25 14:57:13,156 [screen.py:_load_panel()] - Loading panel: job_status
2023-11-25 14:57:13,401 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-11-25 14:57:13,415 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-11-25 14:57:13,444 [job_status.py:update_file_metadata()] - Update Metadata. File: Califlower v13_ABS_1h43m.gcode Size: 5213336
2023-11-25 14:57:13,458 [job_status.py:show_file_thumbnail()] - Califlower v13_ABS_1h43m.gcode
2023-11-25 14:57:14,081 [files.py:add_file()] - File already exists: Califlower v13_ABS_1h43m.gcode
2023-11-25 15:56:13,834 [screen.py:show_screensaver()] - Showing Screensaver
2023-11-25 16:50:15,711 [screen.py:close_screensaver()] - Closing Screensaver
2023-11-25 16:50:15,738 [screen.py:wake_screen()] - Screen wake up
2023-11-25 16:50:15,792 [job_status.py:set_state()] - Changing job_status state from 'printing' to 'complete'
2023-11-25 16:50:18,705 [printer.py:change_state()] - Changing state from 'printing' to 'ready'
2023-11-25 16:50:18,706 [printer.py:change_state()] - Adding callback for state: ready
2023-11-25 17:50:15,838 [screen.py:show_screensaver()] - Showing Screensaver
2023-11-25 18:25:00,512 [printer.py:change_state()] - Changing state from 'ready' to 'disconnected'
2023-11-25 18:25:00,513 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-25 18:25:00,514 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-25 18:25:00,515 [screen.py:close_screensaver()] - Closing Screensaver
2023-11-25 18:25:00,536 [screen.py:wake_screen()] - Screen wake up
2023-11-25 18:25:00,591 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 18:25:00,658 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-25 18:25:03,856 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 18:25:03,877 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 18:25:03,879 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'update_manager', 'history', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-25 18:25:03,896 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-25 18:25:03,898 [printer.py:configure_cameras()] - Cameras: []
2023-11-25 18:25:03,918 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-25 18:25:03,951 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-25 18:25:03,955 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.74', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.93', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'skew_correction': {}, 'bed_mesh default': {'version': '1', 'points': '\n-0.076250, -0.090625, -0.085000\n-0.095625, -0.118750, -0.112500\n-0.044375, -0.082500, -0.095625', 'x_count': '3', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '120.00000000000001', 'max_x': '230.0', 'min_y': '120.0', 'max_y': '230.0'}, 'skew_correction my_skew_profile': {'xy_skew': '0.006789896456448232', 'xz_skew': '0.0', 'yz_skew': '0.0'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[-0.07625, -0.090625, -0.085], [-0.095625, -0.11875, -0.1125], [-0.044375, -0.0825, -0.095625]], 'min_x': 120.00000000000001, 'max_x': 230.0, 'min_y': 120.0, 'max_y': 230.0, 'x_count': 3, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.74, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.93, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'skew_correction my_skew_profile': {'xy_skew': 0.006789896456448232, 'xz_skew': 0.0, 'yz_skew': 0.0}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-25 18:25:03,962 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-11-25 18:25:03,963 [printer.py:reinit()] - # Extruders: 1
2023-11-25 18:25:03,963 [printer.py:reinit()] - # Temperature devices: 5
2023-11-25 18:25:03,963 [printer.py:reinit()] - # Fans: 2
2023-11-25 18:25:03,964 [printer.py:reinit()] - # Output pins: 1
2023-11-25 18:25:03,964 [printer.py:reinit()] - # Leds: 0
2023-11-25 18:25:03,986 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-25 18:25:03,989 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-25 18:25:04,273 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-11-25 18:25:04,327 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-25 18:25:04,337 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-11-25 18:25:04,357 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-25 18:25:04,359 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-25 18:25:04,360 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-25 18:25:04,360 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-25 18:25:04,361 [screen.py:init_printer()] - Printer initialized
2023-11-25 18:25:04,362 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-25 18:25:04,363 [printer.py:change_state()] - Adding callback for state: startup
2023-11-25 18:25:05,442 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-25 18:25:05,442 [printer.py:change_state()] - Adding callback for state: ready
2023-11-25 18:25:05,448 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 18:25:05,565 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-25 18:25:05,578 [main_menu.py:add_device()] - Adding device: extruder
2023-11-25 18:25:05,588 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-25 18:25:05,599 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-11-25 18:25:05,609 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-11-25 18:25:05,618 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-11-25 18:25:05,628 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-11-25 18:25:05,733 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-25 18:25:15,062 [KlippyGtk.py:Dialog()] - Showing dialog KlipperScreen (width=800, height=480)
2023-11-25 18:25:18,117 [printer.py:change_state()] - Changing state from 'ready' to 'disconnected'
2023-11-25 18:25:18,117 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-25 18:25:18,119 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-25 18:25:18,132 [KlippyGtk.py:remove_dialog()] - Removing Dialog
2023-11-25 18:25:18,135 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 18:25:18,233 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-25 18:25:21,852 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 18:25:21,869 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 18:25:21,871 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'update_manager', 'history', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-25 18:25:21,890 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-25 18:25:21,892 [printer.py:configure_cameras()] - Cameras: []
2023-11-25 18:25:21,915 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-25 18:25:21,949 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-25 18:25:21,957 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.74', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.93', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'skew_correction': {}, 'bed_mesh default': {'version': '1', 'points': '\n-0.076250, -0.090625, -0.085000\n-0.095625, -0.118750, -0.112500\n-0.044375, -0.082500, -0.095625', 'x_count': '3', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '120.00000000000001', 'max_x': '230.0', 'min_y': '120.0', 'max_y': '230.0'}, 'skew_correction my_skew_profile': {'xy_skew': '0.0', 'xz_skew': '0.0', 'yz_skew': '0.0'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[-0.07625, -0.090625, -0.085], [-0.095625, -0.11875, -0.1125], [-0.044375, -0.0825, -0.095625]], 'min_x': 120.00000000000001, 'max_x': 230.0, 'min_y': 120.0, 'max_y': 230.0, 'x_count': 3, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.74, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.93, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'skew_correction my_skew_profile': {'xy_skew': 0.0, 'xz_skew': 0.0, 'yz_skew': 0.0}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-25 18:25:21,965 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-11-25 18:25:21,965 [printer.py:reinit()] - # Extruders: 1
2023-11-25 18:25:21,965 [printer.py:reinit()] - # Temperature devices: 5
2023-11-25 18:25:21,965 [printer.py:reinit()] - # Fans: 2
2023-11-25 18:25:21,965 [printer.py:reinit()] - # Output pins: 1
2023-11-25 18:25:21,966 [printer.py:reinit()] - # Leds: 0
2023-11-25 18:25:21,989 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-25 18:25:21,992 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-25 18:25:22,281 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-11-25 18:25:22,409 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-25 18:25:22,419 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-11-25 18:25:22,443 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-25 18:25:22,445 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-25 18:25:22,447 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-25 18:25:22,447 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-25 18:25:22,449 [screen.py:init_printer()] - Printer initialized
2023-11-25 18:25:22,450 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-25 18:25:22,450 [printer.py:change_state()] - Adding callback for state: startup
2023-11-25 18:25:22,937 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-25 18:25:22,937 [printer.py:change_state()] - Adding callback for state: ready
2023-11-25 18:25:22,943 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 18:25:23,060 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-25 18:25:23,074 [main_menu.py:add_device()] - Adding device: extruder
2023-11-25 18:25:23,084 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-25 18:25:23,094 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-11-25 18:25:23,104 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-11-25 18:25:23,114 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-11-25 18:25:23,124 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-11-25 18:25:23,195 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-25 18:26:20,666 [printer.py:change_state()] - Changing state from 'ready' to 'disconnected'
2023-11-25 18:26:20,666 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-25 18:26:20,668 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-25 18:26:20,672 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 18:26:20,740 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-25 18:26:23,852 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 18:26:23,870 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 18:26:23,872 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'update_manager', 'history', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-25 18:26:23,888 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-25 18:26:23,890 [printer.py:configure_cameras()] - Cameras: []
2023-11-25 18:26:23,910 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-25 18:26:23,943 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-25 18:26:23,947 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.66', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.84', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'skew_correction': {}, 'bed_mesh default': {'version': '1', 'points': '\n-0.076250, -0.090625, -0.085000\n-0.095625, -0.118750, -0.112500\n-0.044375, -0.082500, -0.095625', 'x_count': '3', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '120.00000000000001', 'max_x': '230.0', 'min_y': '120.0', 'max_y': '230.0'}, 'skew_correction my_skew_profile': {'xy_skew': '0.0', 'xz_skew': '0.0', 'yz_skew': '0.0'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[-0.07625, -0.090625, -0.085], [-0.095625, -0.11875, -0.1125], [-0.044375, -0.0825, -0.095625]], 'min_x': 120.00000000000001, 'max_x': 230.0, 'min_y': 120.0, 'max_y': 230.0, 'x_count': 3, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.66, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.84, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'skew_correction my_skew_profile': {'xy_skew': 0.0, 'xz_skew': 0.0, 'yz_skew': 0.0}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-25 18:26:23,954 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-11-25 18:26:23,954 [printer.py:reinit()] - # Extruders: 1
2023-11-25 18:26:23,954 [printer.py:reinit()] - # Temperature devices: 5
2023-11-25 18:26:23,955 [printer.py:reinit()] - # Fans: 2
2023-11-25 18:26:23,955 [printer.py:reinit()] - # Output pins: 1
2023-11-25 18:26:23,955 [printer.py:reinit()] - # Leds: 0
2023-11-25 18:26:23,977 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-25 18:26:23,980 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-25 18:26:24,265 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-11-25 18:26:24,320 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-25 18:26:24,330 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-11-25 18:26:24,354 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-25 18:26:24,357 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-25 18:26:24,358 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-25 18:26:24,358 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-25 18:26:24,360 [screen.py:init_printer()] - Printer initialized
2023-11-25 18:26:24,361 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-25 18:26:24,362 [printer.py:change_state()] - Adding callback for state: startup
2023-11-25 18:26:25,690 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-25 18:26:25,691 [printer.py:change_state()] - Adding callback for state: ready
2023-11-25 18:26:25,698 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 18:26:25,816 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-25 18:26:25,830 [main_menu.py:add_device()] - Adding device: extruder
2023-11-25 18:26:25,840 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-25 18:26:25,850 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-11-25 18:26:25,860 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-11-25 18:26:25,870 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-11-25 18:26:25,880 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-11-25 18:26:25,950 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-25 18:29:48,553 [printer.py:change_state()] - Changing state from 'ready' to 'disconnected'
2023-11-25 18:29:48,554 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-25 18:29:48,556 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-25 18:29:48,563 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 18:29:48,687 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-25 18:29:51,855 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 18:29:51,873 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 18:29:51,875 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'error', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'update_manager', 'history', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-25 18:29:51,892 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-25 18:29:51,894 [printer.py:configure_cameras()] - Cameras: []
2023-11-25 18:29:51,914 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-25 18:29:51,973 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-25 18:29:51,975 [screen.py:init_printer()] - {'configfile': {'config': {}, 'settings': {}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-25 18:29:51,977 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-11-25 18:29:51,977 [printer.py:reinit()] - # Extruders: 0
2023-11-25 18:29:51,978 [printer.py:reinit()] - # Temperature devices: 0
2023-11-25 18:29:51,978 [printer.py:reinit()] - # Fans: 0
2023-11-25 18:29:51,978 [printer.py:reinit()] - # Output pins: 0
2023-11-25 18:29:51,978 [printer.py:reinit()] - # Leds: 0
2023-11-25 18:29:52,000 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-25 18:29:52,002 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-25 18:29:52,232 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe
2023-11-25 18:29:52,234 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-25 18:29:52,235 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-25 18:29:52,236 [screen.py:init_printer()] - Printer initialized
2023-11-25 18:29:52,237 [printer.py:change_state()] - Changing state from 'disconnected' to 'error'
2023-11-25 18:29:52,237 [printer.py:change_state()] - Adding callback for state: error
2023-11-25 18:29:52,241 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 18:29:52,321 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-25 18:31:17,505 [printer.py:change_state()] - Changing state from 'error' to 'disconnected'
2023-11-25 18:31:17,506 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-25 18:31:17,509 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-25 18:31:17,513 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 18:31:17,600 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-25 18:31:20,850 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 18:31:20,868 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 18:31:20,869 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'error', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'update_manager', 'history', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-25 18:31:20,886 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-25 18:31:20,888 [printer.py:configure_cameras()] - Cameras: []
2023-11-25 18:31:20,908 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-25 18:31:21,114 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-25 18:31:21,116 [screen.py:init_printer()] - {'configfile': {'config': {}, 'settings': {}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-25 18:31:21,117 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-11-25 18:31:21,117 [printer.py:reinit()] - # Extruders: 0
2023-11-25 18:31:21,117 [printer.py:reinit()] - # Temperature devices: 0
2023-11-25 18:31:21,117 [printer.py:reinit()] - # Fans: 0
2023-11-25 18:31:21,117 [printer.py:reinit()] - # Output pins: 0
2023-11-25 18:31:21,118 [printer.py:reinit()] - # Leds: 0
2023-11-25 18:31:21,139 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-25 18:31:21,141 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-25 18:31:21,372 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe
2023-11-25 18:31:21,374 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-25 18:31:21,375 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-25 18:31:21,376 [screen.py:init_printer()] - Printer initialized
2023-11-25 18:31:21,377 [printer.py:change_state()] - Changing state from 'disconnected' to 'error'
2023-11-25 18:31:21,377 [printer.py:change_state()] - Adding callback for state: error
2023-11-25 18:31:21,381 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 18:31:21,462 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-25 18:31:23,168 [printer.py:change_state()] - Changing state from 'error' to 'disconnected'
2023-11-25 18:31:23,169 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-25 18:31:23,171 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-25 18:31:23,175 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 18:31:23,277 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-25 18:31:26,849 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 18:31:26,866 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 18:31:26,868 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'error', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'update_manager', 'history', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-25 18:31:26,885 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-25 18:31:26,887 [printer.py:configure_cameras()] - Cameras: []
2023-11-25 18:31:26,906 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-25 18:31:27,038 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-25 18:31:27,040 [screen.py:init_printer()] - {'configfile': {'config': {}, 'settings': {}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-25 18:31:27,041 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-11-25 18:31:27,041 [printer.py:reinit()] - # Extruders: 0
2023-11-25 18:31:27,041 [printer.py:reinit()] - # Temperature devices: 0
2023-11-25 18:31:27,042 [printer.py:reinit()] - # Fans: 0
2023-11-25 18:31:27,042 [printer.py:reinit()] - # Output pins: 0
2023-11-25 18:31:27,042 [printer.py:reinit()] - # Leds: 0
2023-11-25 18:31:27,064 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-25 18:31:27,066 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-25 18:31:27,308 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe
2023-11-25 18:31:27,312 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-25 18:31:27,312 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-25 18:31:27,314 [screen.py:init_printer()] - Printer initialized
2023-11-25 18:31:27,315 [printer.py:change_state()] - Changing state from 'disconnected' to 'error'
2023-11-25 18:31:27,316 [printer.py:change_state()] - Adding callback for state: error
2023-11-25 18:31:27,322 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 18:31:27,449 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-25 18:33:13,555 [printer.py:change_state()] - Changing state from 'error' to 'disconnected'
2023-11-25 18:33:13,555 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-25 18:33:13,557 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-25 18:33:13,561 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 18:33:13,664 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-25 18:33:16,849 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 18:33:16,869 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 18:33:16,871 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'update_manager', 'history', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-25 18:33:16,895 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-25 18:33:16,899 [printer.py:configure_cameras()] - Cameras: []
2023-11-25 18:33:16,920 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-25 18:33:16,952 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-25 18:33:16,957 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.66', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.84', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'skew_correction': {}, 'bed_mesh default': {'version': '1', 'points': '\n-0.076250, -0.090625, -0.085000\n-0.095625, -0.118750, -0.112500\n-0.044375, -0.082500, -0.095625', 'x_count': '3', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '120.00000000000001', 'max_x': '230.0', 'min_y': '120.0', 'max_y': '230.0'}, 'skew_correction my_skew_profile': {'xy_skew': '0.0', 'xz_skew': '0.0', 'yz_skew': '0.0'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[-0.07625, -0.090625, -0.085], [-0.095625, -0.11875, -0.1125], [-0.044375, -0.0825, -0.095625]], 'min_x': 120.00000000000001, 'max_x': 230.0, 'min_y': 120.0, 'max_y': 230.0, 'x_count': 3, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.66, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.84, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'skew_correction my_skew_profile': {'xy_skew': 0.0, 'xz_skew': 0.0, 'yz_skew': 0.0}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-25 18:33:16,962 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-11-25 18:33:16,963 [printer.py:reinit()] - # Extruders: 1
2023-11-25 18:33:16,963 [printer.py:reinit()] - # Temperature devices: 5
2023-11-25 18:33:16,963 [printer.py:reinit()] - # Fans: 2
2023-11-25 18:33:16,964 [printer.py:reinit()] - # Output pins: 1
2023-11-25 18:33:16,964 [printer.py:reinit()] - # Leds: 0
2023-11-25 18:33:16,987 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-25 18:33:16,990 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-25 18:33:17,274 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-11-25 18:33:17,325 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-25 18:33:17,335 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-11-25 18:33:17,354 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-25 18:33:17,357 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-25 18:33:17,357 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-25 18:33:17,358 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-25 18:33:17,359 [screen.py:init_printer()] - Printer initialized
2023-11-25 18:33:17,360 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-25 18:33:17,360 [printer.py:change_state()] - Adding callback for state: startup
2023-11-25 18:33:18,443 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-25 18:33:18,444 [printer.py:change_state()] - Adding callback for state: ready
2023-11-25 18:33:18,450 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 18:33:18,572 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-25 18:33:18,586 [main_menu.py:add_device()] - Adding device: extruder
2023-11-25 18:33:18,597 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-25 18:33:18,607 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-11-25 18:33:18,618 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-11-25 18:33:18,629 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-11-25 18:33:18,640 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-11-25 18:33:18,714 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-25 18:44:16,961 [files.py:_callback()] - Error in getting metadata for .thumbs/MicroATX_MB_v3_2_ABS_5h8m-350x350.png. Retrying in 6 seconds
2023-11-25 18:44:16,970 [files.py:_callback()] - Error in getting metadata for .thumbs/MicroATX_MB_v3_2_ABS_5h8m-32x32.png. Retrying in 6 seconds
2023-11-25 18:44:17,068 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-11-25 18:44:17,069 [printer.py:change_state()] - Adding callback for state: printing
2023-11-25 18:44:17,204 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 18:44:17,723 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-11-25 18:44:17,735 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-11-25 18:44:17,761 [job_status.py:update_file_metadata()] - Update Metadata. File: MicroATX_MB_v3_2_ABS_5h8m.gcode Size: 15259282
2023-11-25 18:44:17,782 [job_status.py:show_file_thumbnail()] - MicroATX_MB_v3_2_ABS_5h8m.gcode
2023-11-25 18:49:36,972 [printer.py:change_state()] - Changing state from 'printing' to 'shutdown'
2023-11-25 18:49:36,973 [printer.py:change_state()] - Adding callback for state: shutdown
2023-11-25 18:49:37,013 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 18:49:37,111 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-25 18:49:38,753 [printer.py:change_state()] - Changing state from 'shutdown' to 'disconnected'
2023-11-25 18:49:38,753 [printer.py:change_state()] - Adding callback for state: disconnected
2023-11-25 18:49:38,756 [screen.py:state_disconnected()] - ### Going to disconnected
2023-11-25 18:49:38,758 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 18:49:38,826 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-25 18:49:41,880 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 18:49:41,899 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-25 18:49:41,901 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'update_manager', 'history', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-25 18:49:41,919 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-25 18:49:41,921 [printer.py:configure_cameras()] - Cameras: []
2023-11-25 18:49:41,946 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-25 18:49:41,991 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-25 18:49:41,996 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.66', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.84', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'skew_correction': {}, 'bed_mesh default': {'version': '1', 'points': '\n-0.076250, -0.090625, -0.085000\n-0.095625, -0.118750, -0.112500\n-0.044375, -0.082500, -0.095625', 'x_count': '3', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '120.00000000000001', 'max_x': '230.0', 'min_y': '120.0', 'max_y': '230.0'}, 'skew_correction my_skew_profile': {'xy_skew': '0.0', 'xz_skew': '0.0', 'yz_skew': '0.0'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[-0.07625, -0.090625, -0.085], [-0.095625, -0.11875, -0.1125], [-0.044375, -0.0825, -0.095625]], 'min_x': 120.00000000000001, 'max_x': 230.0, 'min_y': 120.0, 'max_y': 230.0, 'x_count': 3, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.66, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.84, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'skew_correction my_skew_profile': {'xy_skew': 0.0, 'xz_skew': 0.0, 'yz_skew': 0.0}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-25 18:49:42,005 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-11-25 18:49:42,006 [printer.py:reinit()] - # Extruders: 1
2023-11-25 18:49:42,006 [printer.py:reinit()] - # Temperature devices: 5
2023-11-25 18:49:42,007 [printer.py:reinit()] - # Fans: 2
2023-11-25 18:49:42,009 [printer.py:reinit()] - # Output pins: 1
2023-11-25 18:49:42,010 [printer.py:reinit()] - # Leds: 0
2023-11-25 18:49:42,038 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-25 18:49:42,043 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-25 18:49:42,304 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-11-25 18:49:42,355 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-25 18:49:42,365 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-11-25 18:49:42,387 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-25 18:49:42,389 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-25 18:49:42,390 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-25 18:49:42,391 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-25 18:49:42,392 [screen.py:init_printer()] - Printer initialized
2023-11-25 18:49:42,393 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-11-25 18:49:42,393 [printer.py:change_state()] - Adding callback for state: startup
2023-11-25 18:49:43,983 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-11-25 18:49:43,983 [printer.py:change_state()] - Adding callback for state: ready
2023-11-25 18:49:43,991 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 18:49:44,123 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-25 18:49:44,137 [main_menu.py:add_device()] - Adding device: extruder
2023-11-25 18:49:44,147 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-25 18:49:44,158 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-11-25 18:49:44,168 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-11-25 18:49:44,178 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-11-25 18:49:44,189 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-11-25 18:49:44,259 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-25 18:50:00,690 [files.py:_callback()] - Error in getting metadata for .thumbs/MicroATX_MB_v3_2_ABS_7h46m-350x350.png. Retrying in 6 seconds
2023-11-25 18:50:00,695 [files.py:_callback()] - Error in getting metadata for .thumbs/MicroATX_MB_v3_2_ABS_7h46m-32x32.png. Retrying in 6 seconds
2023-11-25 18:50:00,841 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-11-25 18:50:00,842 [printer.py:change_state()] - Adding callback for state: printing
2023-11-25 18:50:00,848 [screen.py:show_panel()] - Reinitializing panel
2023-11-25 18:50:01,059 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-11-25 18:50:01,074 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-11-25 18:50:01,088 [job_status.py:update_file_metadata()] - Update Metadata. File: MicroATX_MB_v3_2_ABS_7h46m.gcode Size: 25209864
2023-11-25 18:50:01,098 [job_status.py:show_file_thumbnail()] - MicroATX_MB_v3_2_ABS_7h46m.gcode
2023-11-25 19:25:00,836 [screen.py:show_screensaver()] - Showing Screensaver
2023-11-26 02:35:47,134 [screen.py:close_screensaver()] - Closing Screensaver
2023-11-26 02:35:47,154 [screen.py:wake_screen()] - Screen wake up
2023-11-26 02:35:47,467 [job_status.py:set_state()] - Changing job_status state from 'printing' to 'complete'
2023-11-26 02:35:51,642 [printer.py:change_state()] - Changing state from 'printing' to 'ready'
2023-11-26 02:35:51,643 [printer.py:change_state()] - Adding callback for state: ready
--------------------KlipperScreen Log Start--------------------
Git Version: v0.3.6-65-g4a14962
2023-11-26 03:17:22,799 [screen.py:main()] - Python version: 3.9
2023-11-26 03:17:22,800 [screen.py:main()] - KlipperScreen version: v0.3.6-65-g4a14962
2023-11-26 03:17:22,821 [functions.py:detect_desktop_environment()] - Error:
'XDG_CURRENT_DESKTOP'

Traceback (most recent call last):
  File "/home/biqu/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.9/os.py", line 679, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
Traceback (most recent call last):
  File "/home/biqu/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.9/os.py", line 679, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
2023-11-26 03:17:23,143 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-11-26 03:17:23,146 [config.py:__init__()] - Config path location: /home/biqu/printer_data/config/KlipperScreen.conf
2023-11-26 03:17:23,180 [config.py:log_config()] -  ===== Config File =====

=======================
2023-11-26 03:17:23,183 [config.py:__init__()] - ====== Saved Def ======

[main]
print_sort_dir = date_asc

[graph Printer]
extruder = False

=======================
2023-11-26 03:17:23,184 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-11-26 03:17:23,308 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-11-26 03:17:23,310 [config.py:install_language()] - Using system lang
2023-11-26 03:17:23,311 [config.py:install_language()] - Using lang en
2023-11-26 03:17:23,365 [screen.py:__init__()] - Screen resolution: 800x480
2023-11-26 03:17:23,369 [KlippyGtk.py:__init__()] - Font size: 16.6 (medium)
2023-11-26 03:17:25,028 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-11-26 03:17:25,043 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-11-26 03:17:25,053 [screen.py:initial_connection()] - Default printer: None
2023-11-26 03:17:25,053 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-11-26 03:17:25,054 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-11-26 03:17:25,149 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-11-26 03:17:25,169 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-11-26 03:17:25,318 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-26 03:17:25,345 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-11-26 03:17:25,347 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-11-26 03:17:25,381 [_logging.py:info()] - Websocket connected
2023-11-26 03:17:25,382 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-11-26 03:17:25,738 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-26 03:17:25,762 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-26 03:17:25,764 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'authorization', 'update_manager', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-26 03:17:25,857 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-26 03:17:25,861 [printer.py:configure_cameras()] - Cameras: []
2023-11-26 03:17:25,862 [screen.py:init_printer()] - Klipper not connected
2023-11-26 03:17:28,957 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-26 03:17:28,978 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-26 03:17:28,980 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'authorization', 'update_manager', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-26 03:17:29,000 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-26 03:17:29,002 [printer.py:configure_cameras()] - Cameras: []
2023-11-26 03:17:29,003 [screen.py:init_printer()] - Klipper not connected
2023-11-26 03:17:31,958 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-26 03:17:31,978 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-26 03:17:31,980 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'authorization', 'update_manager', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-26 03:17:31,998 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-26 03:17:32,000 [printer.py:configure_cameras()] - Cameras: []
2023-11-26 03:17:32,032 [KlippyRest.py:_do_request()] - 404 Client Error>>Not Found for url>>http://127.0.0.1:7125/printer/info
2023-11-26 03:17:34,960 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-26 03:17:34,981 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-11-26 03:17:34,983 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'authorization', 'update_manager', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-11-26 03:17:35,006 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-11-26 03:17:35,010 [printer.py:configure_cameras()] - Cameras: []
2023-11-26 03:17:35,034 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-11-26 03:17:35,071 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-11-26 03:17:35,075 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.66', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.84', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'skew_correction': {}, 'bed_mesh default': {'version': '1', 'points': '\n-0.076250, -0.090625, -0.085000\n-0.095625, -0.118750, -0.112500\n-0.044375, -0.082500, -0.095625', 'x_count': '3', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '120.00000000000001', 'max_x': '230.0', 'min_y': '120.0', 'max_y': '230.0'}, 'skew_correction my_skew_profile': {'xy_skew': '0.0', 'xz_skew': '0.0', 'yz_skew': '0.0'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[-0.07625, -0.090625, -0.085], [-0.095625, -0.11875, -0.1125], [-0.044375, -0.0825, -0.095625]], 'min_x': 120.00000000000001, 'max_x': 230.0, 'min_y': 120.0, 'max_y': 230.0, 'x_count': 3, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.66, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.84, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'skew_correction my_skew_profile': {'xy_skew': 0.0, 'xz_skew': 0.0, 'yz_skew': 0.0}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-11-26 03:17:35,080 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-11-26 03:17:35,080 [printer.py:reinit()] - # Extruders: 1
2023-11-26 03:17:35,081 [printer.py:reinit()] - # Temperature devices: 5
2023-11-26 03:17:35,081 [printer.py:reinit()] - # Fans: 2
2023-11-26 03:17:35,081 [printer.py:reinit()] - # Output pins: 1
2023-11-26 03:17:35,081 [printer.py:reinit()] - # Leds: 0
2023-11-26 03:17:35,110 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-11-26 03:17:35,113 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-11-26 03:17:35,400 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-11-26 03:17:35,421 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-26 03:17:35,423 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-11-26 03:17:35,424 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-11-26 03:17:35,424 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-11-26 03:17:35,425 [screen.py:init_printer()] - Printer initialized
2023-11-26 03:17:35,426 [printer.py:change_state()] - Changing state from 'disconnected' to 'ready'
2023-11-26 03:17:35,427 [printer.py:change_state()] - Adding callback for state: ready
2023-11-26 03:17:35,433 [screen.py:_load_panel()] - Loading panel: main_menu
2023-11-26 03:17:35,585 [main_menu.py:__init__()] - ### Making MainMenu
2023-11-26 03:17:35,598 [main_menu.py:add_device()] - Adding device: extruder
2023-11-26 03:17:35,608 [main_menu.py:add_device()] - Adding device: heater_bed
2023-11-26 03:17:35,620 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-11-26 03:17:35,632 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-11-26 03:17:35,644 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-11-26 03:17:35,655 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-11-26 03:17:35,722 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-11-26 03:17:35,724 [main_menu.py:update_graph_visibility()] - Could not create graph tempstore: []
2023-11-26 03:17:40,953 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-11-26 03:17:40,981 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-11-26 03:17:41,004 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-11-26 03:17:41,007 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-11-26 03:17:56,709 [files.py:_callback()] - Error in getting metadata for .thumbs/Body1_ABS_17m2s-350x350.png. Retrying in 6 seconds
2023-11-26 03:17:56,712 [files.py:_callback()] - Error in getting metadata for .thumbs/Body1_ABS_17m2s-32x32.png. Retrying in 6 seconds
2023-11-26 03:17:56,875 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-11-26 03:17:56,875 [printer.py:change_state()] - Adding callback for state: printing
2023-11-26 03:17:56,915 [screen.py:_load_panel()] - Loading panel: job_status
2023-11-26 03:17:57,148 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-11-26 03:17:57,159 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-11-26 03:17:57,186 [job_status.py:update_file_metadata()] - Update Metadata. File: Body1_ABS_17m2s.gcode Size: 487000
2023-11-26 03:17:57,200 [job_status.py:show_file_thumbnail()] - Body1_ABS_17m2s.gcode
2023-12-01 11:15:40,510 [job_status.py:set_state()] - Changing job_status state from 'printing' to 'complete'
2023-12-01 11:15:46,255 [printer.py:change_state()] - Changing state from 'printing' to 'ready'
2023-12-01 11:15:46,256 [printer.py:change_state()] - Adding callback for state: ready
2023-12-01 11:38:54,031 [screen.py:show_screensaver()] - Showing Screensaver
2023-12-01 11:45:00,110 [job_status.py:set_state()] - Changing job_status state from 'complete' to 'standby'
2023-12-01 11:45:00,116 [job_status.py:update_file_metadata()] - Cannot find file metadata. Listening for updated metadata
2023-12-01 11:45:00,116 [job_status.py:show_file_thumbnail()] - (Unsaved)_ABS_1h54m.gcode
2023-12-01 11:45:00,117 [job_status.py:show_file_thumbnail()] - no pixbuf
2023-12-01 11:45:00,120 [files.py:_callback()] - Error in getting metadata for .thumbs/(Unsaved)_ABS_1h54m-350x350.png. Retrying in 6 seconds
2023-12-01 11:45:00,121 [files.py:_callback()] - Error in getting metadata for .thumbs/(Unsaved)_ABS_1h54m-32x32.png. Retrying in 6 seconds
2023-12-01 11:45:00,130 [job_status.py:update_file_metadata()] - Update Metadata. File: (Unsaved)_ABS_1h54m.gcode Size: 4389346
2023-12-01 11:45:00,141 [job_status.py:show_file_thumbnail()] - (Unsaved)_ABS_1h54m.gcode
2023-12-01 11:45:00,338 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-12-01 11:45:00,339 [printer.py:change_state()] - Adding callback for state: printing
2023-12-01 11:45:00,345 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-12-01 11:45:00,359 [screen.py:close_screensaver()] - Closing Screensaver
2023-12-01 11:45:00,382 [screen.py:wake_screen()] - Screen wake up
2023-12-01 11:45:00,438 [screen.py:show_panel()] - Reinitializing panel
2023-12-01 11:45:00,642 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-12-01 11:45:00,653 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-12-01 11:45:00,667 [job_status.py:update_file_metadata()] - Update Metadata. File: (Unsaved)_ABS_1h54m.gcode Size: 4389346
2023-12-01 11:45:00,676 [job_status.py:show_file_thumbnail()] - (Unsaved)_ABS_1h54m.gcode
2023-12-01 12:45:01,032 [screen.py:show_screensaver()] - Showing Screensaver
2023-12-01 13:45:25,836 [screen.py:close_screensaver()] - Closing Screensaver
2023-12-01 13:45:25,860 [screen.py:wake_screen()] - Screen wake up
2023-12-01 13:45:25,915 [job_status.py:set_state()] - Changing job_status state from 'printing' to 'complete'
2023-12-01 13:45:31,851 [printer.py:change_state()] - Changing state from 'printing' to 'ready'
2023-12-01 13:45:31,851 [printer.py:change_state()] - Adding callback for state: ready
2023-12-01 14:45:26,033 [screen.py:show_screensaver()] - Showing Screensaver
--------------------KlipperScreen Log Start--------------------
Git Version: v0.3.6-65-g4a14962
2023-12-01 20:17:20,888 [screen.py:main()] - Python version: 3.9
2023-12-01 20:17:20,890 [screen.py:main()] - KlipperScreen version: v0.3.6-65-g4a14962
2023-12-01 20:17:20,910 [functions.py:detect_desktop_environment()] - Error:
'XDG_CURRENT_DESKTOP'

Traceback (most recent call last):
  File "/home/biqu/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.9/os.py", line 679, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
Traceback (most recent call last):
  File "/home/biqu/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.9/os.py", line 679, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
2023-12-01 20:17:21,278 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-12-01 20:17:21,280 [config.py:__init__()] - Config path location: /home/biqu/printer_data/config/KlipperScreen.conf
2023-12-01 20:17:21,334 [config.py:log_config()] -  ===== Config File =====

=======================
2023-12-01 20:17:21,342 [config.py:__init__()] - ====== Saved Def ======

[main]
print_sort_dir = date_asc

[graph Printer]
extruder = False

=======================
2023-12-01 20:17:21,344 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-12-01 20:17:21,597 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-12-01 20:17:21,598 [config.py:install_language()] - Using system lang
2023-12-01 20:17:21,599 [config.py:install_language()] - Using lang en
2023-12-01 20:17:21,634 [screen.py:__init__()] - Screen resolution: 800x480
2023-12-01 20:17:21,638 [KlippyGtk.py:__init__()] - Font size: 16.6 (medium)
2023-12-01 20:17:23,074 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-12-01 20:17:23,088 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-12-01 20:17:23,099 [screen.py:initial_connection()] - Default printer: None
2023-12-01 20:17:23,099 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-12-01 20:17:23,100 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-12-01 20:17:23,207 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-12-01 20:17:23,222 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-12-01 20:17:23,262 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-01 20:17:23,281 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-12-01 20:17:23,284 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-12-01 20:17:23,298 [_logging.py:info()] - Websocket connected
2023-12-01 20:17:23,299 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-12-01 20:17:23,581 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-01 20:17:23,600 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-01 20:17:23,602 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'octoprint_compat', 'history', 'authorization'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-01 20:17:23,620 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-01 20:17:23,622 [printer.py:configure_cameras()] - Cameras: []
2023-12-01 20:17:23,622 [screen.py:init_printer()] - Klipper not connected
2023-12-01 20:17:26,950 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-01 20:17:26,974 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-01 20:17:26,977 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'octoprint_compat', 'history', 'authorization'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-01 20:17:26,998 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-01 20:17:27,000 [printer.py:configure_cameras()] - Cameras: []
2023-12-01 20:17:27,001 [screen.py:init_printer()] - Klipper not connected
2023-12-01 20:17:29,951 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-01 20:17:29,971 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-01 20:17:29,973 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'octoprint_compat', 'history', 'authorization'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-01 20:17:29,992 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-01 20:17:29,994 [printer.py:configure_cameras()] - Cameras: []
2023-12-01 20:17:29,994 [screen.py:init_printer()] - Klipper not connected
2023-12-01 20:17:32,949 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-01 20:17:32,967 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-01 20:17:32,969 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'update_manager', 'octoprint_compat', 'history', 'authorization'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-01 20:17:32,985 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-01 20:17:32,987 [printer.py:configure_cameras()] - Cameras: []
2023-12-01 20:17:33,007 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-12-01 20:17:33,042 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-12-01 20:17:33,046 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.66', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.84', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'skew_correction': {}, 'bed_mesh default': {'version': '1', 'points': '\n-0.076250, -0.090625, -0.085000\n-0.095625, -0.118750, -0.112500\n-0.044375, -0.082500, -0.095625', 'x_count': '3', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '120.00000000000001', 'max_x': '230.0', 'min_y': '120.0', 'max_y': '230.0'}, 'skew_correction my_skew_profile': {'xy_skew': '0.0', 'xz_skew': '0.0', 'yz_skew': '0.0'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[-0.07625, -0.090625, -0.085], [-0.095625, -0.11875, -0.1125], [-0.044375, -0.0825, -0.095625]], 'min_x': 120.00000000000001, 'max_x': 230.0, 'min_y': 120.0, 'max_y': 230.0, 'x_count': 3, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.66, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.84, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'skew_correction my_skew_profile': {'xy_skew': 0.0, 'xz_skew': 0.0, 'yz_skew': 0.0}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-12-01 20:17:33,051 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-12-01 20:17:33,051 [printer.py:reinit()] - # Extruders: 1
2023-12-01 20:17:33,052 [printer.py:reinit()] - # Temperature devices: 5
2023-12-01 20:17:33,052 [printer.py:reinit()] - # Fans: 2
2023-12-01 20:17:33,052 [printer.py:reinit()] - # Output pins: 1
2023-12-01 20:17:33,053 [printer.py:reinit()] - # Leds: 0
2023-12-01 20:17:33,075 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-12-01 20:17:33,079 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-12-01 20:17:33,368 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-12-01 20:17:33,395 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-12-01 20:17:33,397 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-12-01 20:17:33,398 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-12-01 20:17:33,399 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-12-01 20:17:33,401 [screen.py:init_printer()] - Printer initialized
2023-12-01 20:17:33,402 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-12-01 20:17:33,402 [printer.py:change_state()] - Adding callback for state: startup
2023-12-01 20:17:35,290 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-12-01 20:17:35,290 [printer.py:change_state()] - Adding callback for state: ready
2023-12-01 20:17:35,296 [screen.py:_load_panel()] - Loading panel: main_menu
2023-12-01 20:17:35,430 [main_menu.py:__init__()] - ### Making MainMenu
2023-12-01 20:17:35,444 [main_menu.py:add_device()] - Adding device: extruder
2023-12-01 20:17:35,456 [main_menu.py:add_device()] - Adding device: heater_bed
2023-12-01 20:17:35,469 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-12-01 20:17:35,483 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-12-01 20:17:35,493 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-12-01 20:17:35,504 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-12-01 20:17:35,576 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-12-01 20:17:35,579 [main_menu.py:update_graph_visibility()] - Could not create graph tempstore: []
2023-12-01 20:17:38,954 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-12-01 20:17:39,022 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-12-01 20:17:39,061 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-12-01 20:17:39,066 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-12-02 10:36:30,168 [files.py:_callback()] - Error in getting metadata for .thumbs/RACK_POWER v1_ABS_5h37m-350x350.png. Retrying in 6 seconds
2023-12-02 10:36:30,176 [files.py:_callback()] - Error in getting metadata for .thumbs/RACK_POWER v1_ABS_5h37m-32x32.png. Retrying in 6 seconds
2023-12-02 10:36:30,338 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-12-02 10:36:30,339 [printer.py:change_state()] - Adding callback for state: printing
2023-12-02 10:36:30,377 [screen.py:_load_panel()] - Loading panel: job_status
2023-12-02 10:36:30,614 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-12-02 10:36:30,627 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-12-02 10:36:30,657 [job_status.py:update_file_metadata()] - Update Metadata. File: RACK_POWER v1_ABS_5h37m.gcode Size: 26870925
2023-12-02 10:36:30,672 [job_status.py:show_file_thumbnail()] - RACK_POWER v1_ABS_5h37m.gcode
2023-12-02 11:34:47,464 [screen.py:show_screensaver()] - Showing Screensaver
2023-12-02 16:21:21,364 [screen.py:close_screensaver()] - Closing Screensaver
2023-12-02 16:21:21,393 [screen.py:wake_screen()] - Screen wake up
2023-12-02 16:21:21,447 [job_status.py:set_state()] - Changing job_status state from 'printing' to 'complete'
2023-12-02 16:21:27,628 [printer.py:change_state()] - Changing state from 'printing' to 'ready'
2023-12-02 16:21:27,628 [printer.py:change_state()] - Adding callback for state: ready
--------------------KlipperScreen Log Start--------------------
Git Version: v0.3.6-65-g4a14962
2023-12-02 16:17:22,645 [screen.py:main()] - Python version: 3.9
2023-12-02 16:17:22,646 [screen.py:main()] - KlipperScreen version: v0.3.6-65-g4a14962
2023-12-02 16:17:22,663 [functions.py:detect_desktop_environment()] - Error:
'XDG_CURRENT_DESKTOP'

Traceback (most recent call last):
  File "/home/biqu/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.9/os.py", line 679, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
Traceback (most recent call last):
  File "/home/biqu/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.9/os.py", line 679, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
2023-12-02 16:17:22,969 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-12-02 16:17:22,972 [config.py:__init__()] - Config path location: /home/biqu/printer_data/config/KlipperScreen.conf
2023-12-02 16:17:23,010 [config.py:log_config()] -  ===== Config File =====

=======================
2023-12-02 16:17:23,014 [config.py:__init__()] - ====== Saved Def ======

[main]
print_sort_dir = date_asc

[graph Printer]
extruder = False

=======================
2023-12-02 16:17:23,015 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-12-02 16:17:23,129 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-12-02 16:17:23,129 [config.py:install_language()] - Using system lang
2023-12-02 16:17:23,130 [config.py:install_language()] - Using lang en
2023-12-02 16:17:23,168 [screen.py:__init__()] - Screen resolution: 800x480
2023-12-02 16:17:23,173 [KlippyGtk.py:__init__()] - Font size: 16.6 (medium)
2023-12-02 16:17:25,376 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-12-02 16:17:25,394 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-12-02 16:17:25,408 [screen.py:initial_connection()] - Default printer: None
2023-12-02 16:17:25,409 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-12-02 16:17:25,409 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-12-02 16:17:25,515 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-12-02 16:17:25,537 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-12-02 16:17:25,578 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 16:17:25,605 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-12-02 16:17:25,608 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-12-02 16:17:25,627 [_logging.py:info()] - Websocket connected
2023-12-02 16:17:25,627 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-12-02 16:17:25,989 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 16:17:26,016 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 16:17:26,018 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'authorization', 'octoprint_compat', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-02 16:17:26,061 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-02 16:17:26,075 [printer.py:configure_cameras()] - Cameras: []
2023-12-02 16:17:26,081 [screen.py:init_printer()] - Klipper not connected
2023-12-02 16:17:28,997 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 16:17:29,016 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 16:17:29,018 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'authorization', 'octoprint_compat', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-02 16:17:29,036 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-02 16:17:29,039 [printer.py:configure_cameras()] - Cameras: []
2023-12-02 16:17:29,039 [screen.py:init_printer()] - Klipper not connected
2023-12-02 16:17:32,004 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 16:17:32,040 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 16:17:32,042 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'authorization', 'octoprint_compat', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-02 16:17:32,077 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-02 16:17:32,079 [printer.py:configure_cameras()] - Cameras: []
2023-12-02 16:17:32,118 [KlippyRest.py:_do_request()] - 404 Client Error>>Not Found for url>>http://127.0.0.1:7125/printer/info
2023-12-02 16:17:35,001 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 16:17:35,023 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 16:17:35,025 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'authorization', 'octoprint_compat', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-02 16:17:35,050 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-02 16:17:35,054 [printer.py:configure_cameras()] - Cameras: []
2023-12-02 16:17:35,082 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-12-02 16:17:35,128 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-12-02 16:17:35,133 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.66', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.84', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'skew_correction': {}, 'bed_mesh default': {'version': '1', 'points': '\n-0.076250, -0.090625, -0.085000\n-0.095625, -0.118750, -0.112500\n-0.044375, -0.082500, -0.095625', 'x_count': '3', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '120.00000000000001', 'max_x': '230.0', 'min_y': '120.0', 'max_y': '230.0'}, 'skew_correction my_skew_profile': {'xy_skew': '0.0', 'xz_skew': '0.0', 'yz_skew': '0.0'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[-0.07625, -0.090625, -0.085], [-0.095625, -0.11875, -0.1125], [-0.044375, -0.0825, -0.095625]], 'min_x': 120.00000000000001, 'max_x': 230.0, 'min_y': 120.0, 'max_y': 230.0, 'x_count': 3, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.66, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.84, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'skew_correction my_skew_profile': {'xy_skew': 0.0, 'xz_skew': 0.0, 'yz_skew': 0.0}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-12-02 16:17:35,139 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-12-02 16:17:35,140 [printer.py:reinit()] - # Extruders: 1
2023-12-02 16:17:35,141 [printer.py:reinit()] - # Temperature devices: 5
2023-12-02 16:17:35,141 [printer.py:reinit()] - # Fans: 2
2023-12-02 16:17:35,142 [printer.py:reinit()] - # Output pins: 1
2023-12-02 16:17:35,142 [printer.py:reinit()] - # Leds: 0
2023-12-02 16:17:35,191 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-12-02 16:17:35,195 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-12-02 16:17:35,453 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-12-02 16:17:35,477 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-12-02 16:17:35,480 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-12-02 16:17:35,481 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-12-02 16:17:35,481 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-12-02 16:17:35,483 [screen.py:init_printer()] - Printer initialized
2023-12-02 16:17:35,484 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-12-02 16:17:35,484 [printer.py:change_state()] - Adding callback for state: startup
2023-12-02 16:17:36,367 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-12-02 16:17:36,367 [printer.py:change_state()] - Adding callback for state: ready
2023-12-02 16:17:36,372 [screen.py:_load_panel()] - Loading panel: main_menu
2023-12-02 16:17:36,521 [main_menu.py:__init__()] - ### Making MainMenu
2023-12-02 16:17:36,540 [main_menu.py:add_device()] - Adding device: extruder
2023-12-02 16:17:36,554 [main_menu.py:add_device()] - Adding device: heater_bed
2023-12-02 16:17:36,567 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-12-02 16:17:36,580 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-12-02 16:17:36,593 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-12-02 16:17:36,606 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-12-02 16:17:36,693 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-12-02 16:17:36,697 [main_menu.py:update_graph_visibility()] - Could not create graph tempstore: []
2023-12-02 16:17:41,005 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-12-02 16:17:41,039 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-12-02 16:17:41,076 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-12-02 16:17:41,078 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-12-02 18:43:00,592 [files.py:_callback()] - Error in getting metadata for .thumbs/ethernet-rj45-repair_ABS_29m13s-350x350.png. Retrying in 6 seconds
2023-12-02 18:43:00,599 [files.py:_callback()] - Error in getting metadata for .thumbs/ethernet-rj45-repair_ABS_29m13s-32x32.png. Retrying in 6 seconds
2023-12-02 18:43:00,806 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-12-02 18:43:00,807 [printer.py:change_state()] - Adding callback for state: printing
2023-12-02 18:43:00,844 [screen.py:_load_panel()] - Loading panel: job_status
2023-12-02 18:43:01,130 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-12-02 18:43:01,141 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-12-02 18:43:01,173 [job_status.py:update_file_metadata()] - Update Metadata. File: ethernet-rj45-repair_ABS_29m13s.gcode Size: 2782430
2023-12-02 18:43:01,194 [job_status.py:show_file_thumbnail()] - ethernet-rj45-repair_ABS_29m13s.gcode
2023-12-02 19:01:00,301 [printer.py:change_state()] - Changing state from 'printing' to 'shutdown'
2023-12-02 19:01:00,302 [printer.py:change_state()] - Adding callback for state: shutdown
2023-12-02 19:01:00,345 [screen.py:show_panel()] - Reinitializing panel
2023-12-02 19:01:00,415 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
--------------------KlipperScreen Log Start--------------------
Git Version: v0.3.6-65-g4a14962
2023-12-02 19:17:19,997 [screen.py:main()] - Python version: 3.9
2023-12-02 19:17:19,998 [screen.py:main()] - KlipperScreen version: v0.3.6-65-g4a14962
2023-12-02 19:17:20,029 [functions.py:detect_desktop_environment()] - Error:
'XDG_CURRENT_DESKTOP'

Traceback (most recent call last):
  File "/home/biqu/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.9/os.py", line 679, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
Traceback (most recent call last):
  File "/home/biqu/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.9/os.py", line 679, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
2023-12-02 19:17:20,464 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-12-02 19:17:20,469 [config.py:__init__()] - Config path location: /home/biqu/printer_data/config/KlipperScreen.conf
2023-12-02 19:17:20,520 [config.py:log_config()] -  ===== Config File =====

=======================
2023-12-02 19:17:20,526 [config.py:__init__()] - ====== Saved Def ======

[main]
print_sort_dir = date_asc

[graph Printer]
extruder = False

=======================
2023-12-02 19:17:20,528 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-12-02 19:17:20,698 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-12-02 19:17:20,699 [config.py:install_language()] - Using system lang
2023-12-02 19:17:20,700 [config.py:install_language()] - Using lang en
2023-12-02 19:17:20,739 [screen.py:__init__()] - Screen resolution: 800x480
2023-12-02 19:17:20,742 [KlippyGtk.py:__init__()] - Font size: 16.6 (medium)
2023-12-02 19:17:22,546 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-12-02 19:17:22,562 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-12-02 19:17:22,574 [screen.py:initial_connection()] - Default printer: None
2023-12-02 19:17:22,575 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-12-02 19:17:22,576 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-12-02 19:17:22,681 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-12-02 19:17:22,703 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-12-02 19:17:22,747 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 19:17:22,769 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-12-02 19:17:22,771 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-12-02 19:17:22,786 [_logging.py:info()] - Websocket connected
2023-12-02 19:17:22,787 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-12-02 19:17:23,054 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 19:17:23,073 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 19:17:23,075 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'authorization', 'history', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-02 19:17:23,093 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-02 19:17:23,094 [printer.py:configure_cameras()] - Cameras: []
2023-12-02 19:17:23,095 [screen.py:init_printer()] - Klipper not connected
2023-12-02 19:17:26,183 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 19:17:26,215 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 19:17:26,218 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'authorization', 'history', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-02 19:17:26,244 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-02 19:17:26,247 [printer.py:configure_cameras()] - Cameras: []
2023-12-02 19:17:26,248 [screen.py:init_printer()] - Klipper not connected
2023-12-02 19:17:29,171 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 19:17:29,192 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 19:17:29,194 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'authorization', 'history', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-02 19:17:29,212 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-02 19:17:29,214 [printer.py:configure_cameras()] - Cameras: []
2023-12-02 19:17:29,214 [screen.py:init_printer()] - Klipper not connected
2023-12-02 19:17:32,173 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 19:17:32,193 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 19:17:32,195 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'authorization', 'history', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-02 19:17:32,216 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-02 19:17:32,219 [printer.py:configure_cameras()] - Cameras: []
2023-12-02 19:17:32,261 [KlippyRest.py:_do_request()] - 404 Client Error>>Not Found for url>>http://127.0.0.1:7125/printer/info
2023-12-02 19:17:35,173 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 19:17:35,206 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 19:17:35,208 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'authorization', 'history', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-02 19:17:35,225 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-02 19:17:35,227 [printer.py:configure_cameras()] - Cameras: []
2023-12-02 19:17:35,247 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-12-02 19:17:35,449 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-12-02 19:17:35,453 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.66', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.84', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'skew_correction': {}, 'bed_mesh default': {'version': '1', 'points': '\n-0.076250, -0.090625, -0.085000\n-0.095625, -0.118750, -0.112500\n-0.044375, -0.082500, -0.095625', 'x_count': '3', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '120.00000000000001', 'max_x': '230.0', 'min_y': '120.0', 'max_y': '230.0'}, 'skew_correction my_skew_profile': {'xy_skew': '0.0', 'xz_skew': '0.0', 'yz_skew': '0.0'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[-0.07625, -0.090625, -0.085], [-0.095625, -0.11875, -0.1125], [-0.044375, -0.0825, -0.095625]], 'min_x': 120.00000000000001, 'max_x': 230.0, 'min_y': 120.0, 'max_y': 230.0, 'x_count': 3, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.66, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.84, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'skew_correction my_skew_profile': {'xy_skew': 0.0, 'xz_skew': 0.0, 'yz_skew': 0.0}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-12-02 19:17:35,458 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-12-02 19:17:35,459 [printer.py:reinit()] - # Extruders: 1
2023-12-02 19:17:35,459 [printer.py:reinit()] - # Temperature devices: 5
2023-12-02 19:17:35,459 [printer.py:reinit()] - # Fans: 2
2023-12-02 19:17:35,460 [printer.py:reinit()] - # Output pins: 1
2023-12-02 19:17:35,460 [printer.py:reinit()] - # Leds: 0
2023-12-02 19:17:35,493 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-12-02 19:17:35,498 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-12-02 19:17:35,780 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-12-02 19:17:35,801 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-12-02 19:17:35,803 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-12-02 19:17:35,804 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-12-02 19:17:35,804 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-12-02 19:17:35,806 [screen.py:init_printer()] - Printer initialized
2023-12-02 19:17:35,807 [printer.py:change_state()] - Changing state from 'disconnected' to 'ready'
2023-12-02 19:17:35,807 [printer.py:change_state()] - Adding callback for state: ready
2023-12-02 19:17:35,814 [screen.py:_load_panel()] - Loading panel: main_menu
2023-12-02 19:17:35,973 [main_menu.py:__init__()] - ### Making MainMenu
2023-12-02 19:17:35,986 [main_menu.py:add_device()] - Adding device: extruder
2023-12-02 19:17:35,998 [main_menu.py:add_device()] - Adding device: heater_bed
2023-12-02 19:17:36,015 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-12-02 19:17:36,029 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-12-02 19:17:36,043 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-12-02 19:17:36,057 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-12-02 19:17:36,159 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-12-02 19:17:36,164 [main_menu.py:update_graph_visibility()] - Could not create graph tempstore: []
2023-12-02 19:17:41,163 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-12-02 19:17:41,195 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-12-02 19:17:41,220 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-12-02 19:17:41,223 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-12-02 19:17:47,974 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-12-02 19:17:47,975 [printer.py:change_state()] - Adding callback for state: printing
2023-12-02 19:17:47,998 [screen.py:_load_panel()] - Loading panel: job_status
2023-12-02 19:17:48,266 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-12-02 19:17:48,277 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-12-02 19:17:48,304 [job_status.py:update_file_metadata()] - Update Metadata. File: ethernet-rj45-repair_ABS_29m13s.gcode Size: 2782430
2023-12-02 19:17:48,319 [job_status.py:show_file_thumbnail()] - ethernet-rj45-repair_ABS_29m13s.gcode
2023-12-02 19:17:48,965 [files.py:add_file()] - File already exists: ethernet-rj45-repair_ABS_29m13s.gcode
2023-12-02 19:56:08,963 [job_status.py:set_state()] - Changing job_status state from 'printing' to 'complete'
2023-12-02 19:56:14,459 [printer.py:change_state()] - Changing state from 'printing' to 'ready'
2023-12-02 19:56:14,460 [printer.py:change_state()] - Adding callback for state: ready
2023-12-02 20:21:04,520 [screen.py:show_screensaver()] - Showing Screensaver
--------------------KlipperScreen Log Start--------------------
Git Version: v0.3.6-65-g4a14962
2023-12-02 21:17:22,303 [screen.py:main()] - Python version: 3.9
2023-12-02 21:17:22,304 [screen.py:main()] - KlipperScreen version: v0.3.6-65-g4a14962
2023-12-02 21:17:22,316 [functions.py:detect_desktop_environment()] - Error:
'XDG_CURRENT_DESKTOP'

Traceback (most recent call last):
  File "/home/biqu/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.9/os.py", line 679, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
Traceback (most recent call last):
  File "/home/biqu/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.9/os.py", line 679, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
2023-12-02 21:17:22,613 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-12-02 21:17:22,616 [config.py:__init__()] - Config path location: /home/biqu/printer_data/config/KlipperScreen.conf
2023-12-02 21:17:22,661 [config.py:log_config()] -  ===== Config File =====

=======================
2023-12-02 21:17:22,665 [config.py:__init__()] - ====== Saved Def ======

[main]
print_sort_dir = date_asc

[graph Printer]
extruder = False

=======================
2023-12-02 21:17:22,666 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-12-02 21:17:22,863 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-12-02 21:17:22,864 [config.py:install_language()] - Using system lang
2023-12-02 21:17:22,865 [config.py:install_language()] - Using lang en
2023-12-02 21:17:22,901 [screen.py:__init__()] - Screen resolution: 800x480
2023-12-02 21:17:22,904 [KlippyGtk.py:__init__()] - Font size: 16.6 (medium)
2023-12-02 21:17:24,893 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-12-02 21:17:24,932 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-12-02 21:17:24,962 [screen.py:initial_connection()] - Default printer: None
2023-12-02 21:17:24,963 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-12-02 21:17:24,964 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-12-02 21:17:25,123 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-12-02 21:17:25,169 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-12-02 21:17:25,236 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 21:17:25,272 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-12-02 21:17:25,277 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-12-02 21:17:25,311 [_logging.py:info()] - Websocket connected
2023-12-02 21:17:25,312 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-12-02 21:17:25,847 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 21:17:25,875 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 21:17:25,881 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'history', 'octoprint_compat', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-02 21:17:25,940 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-02 21:17:25,946 [printer.py:configure_cameras()] - Cameras: []
2023-12-02 21:17:25,950 [screen.py:init_printer()] - Klipper not connected
2023-12-02 21:17:29,323 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 21:17:29,366 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 21:17:29,369 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'history', 'octoprint_compat', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-02 21:17:29,389 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-02 21:17:29,391 [printer.py:configure_cameras()] - Cameras: []
2023-12-02 21:17:29,392 [screen.py:init_printer()] - Klipper not connected
2023-12-02 21:17:32,325 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 21:17:32,361 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 21:17:32,364 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'history', 'octoprint_compat', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-02 21:17:32,386 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-02 21:17:32,389 [printer.py:configure_cameras()] - Cameras: []
2023-12-02 21:17:32,426 [KlippyRest.py:_do_request()] - 404 Client Error>>Not Found for url>>http://127.0.0.1:7125/printer/info
2023-12-02 21:17:35,318 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 21:17:35,337 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-02 21:17:35,339 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'history', 'octoprint_compat', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-02 21:17:35,360 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-02 21:17:35,362 [printer.py:configure_cameras()] - Cameras: []
2023-12-02 21:17:35,381 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-12-02 21:17:35,488 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-12-02 21:17:35,492 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.66', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.84', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'skew_correction': {}, 'bed_mesh default': {'version': '1', 'points': '\n-0.076250, -0.090625, -0.085000\n-0.095625, -0.118750, -0.112500\n-0.044375, -0.082500, -0.095625', 'x_count': '3', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '120.00000000000001', 'max_x': '230.0', 'min_y': '120.0', 'max_y': '230.0'}, 'skew_correction my_skew_profile': {'xy_skew': '0.0', 'xz_skew': '0.0', 'yz_skew': '0.0'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[-0.07625, -0.090625, -0.085], [-0.095625, -0.11875, -0.1125], [-0.044375, -0.0825, -0.095625]], 'min_x': 120.00000000000001, 'max_x': 230.0, 'min_y': 120.0, 'max_y': 230.0, 'x_count': 3, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.66, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.84, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'skew_correction my_skew_profile': {'xy_skew': 0.0, 'xz_skew': 0.0, 'yz_skew': 0.0}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-12-02 21:17:35,497 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-12-02 21:17:35,497 [printer.py:reinit()] - # Extruders: 1
2023-12-02 21:17:35,497 [printer.py:reinit()] - # Temperature devices: 5
2023-12-02 21:17:35,498 [printer.py:reinit()] - # Fans: 2
2023-12-02 21:17:35,498 [printer.py:reinit()] - # Output pins: 1
2023-12-02 21:17:35,498 [printer.py:reinit()] - # Leds: 0
2023-12-02 21:17:35,521 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-12-02 21:17:35,524 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-12-02 21:17:35,825 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-12-02 21:17:35,846 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-12-02 21:17:35,848 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-12-02 21:17:35,849 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-12-02 21:17:35,849 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-12-02 21:17:35,850 [screen.py:init_printer()] - Printer initialized
2023-12-02 21:17:35,852 [printer.py:change_state()] - Changing state from 'disconnected' to 'ready'
2023-12-02 21:17:35,852 [printer.py:change_state()] - Adding callback for state: ready
2023-12-02 21:17:35,859 [screen.py:_load_panel()] - Loading panel: main_menu
2023-12-02 21:17:36,012 [main_menu.py:__init__()] - ### Making MainMenu
2023-12-02 21:17:36,026 [main_menu.py:add_device()] - Adding device: extruder
2023-12-02 21:17:36,036 [main_menu.py:add_device()] - Adding device: heater_bed
2023-12-02 21:17:36,047 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-12-02 21:17:36,056 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-12-02 21:17:36,066 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-12-02 21:17:36,076 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-12-02 21:17:36,165 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-12-02 21:17:36,171 [main_menu.py:update_graph_visibility()] - Could not create graph tempstore: []
2023-12-02 21:17:41,317 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-12-02 21:17:41,345 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-12-02 21:17:41,372 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-12-02 21:17:41,374 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-12-03 11:05:42,416 [files.py:_callback()] - Error in getting metadata for .thumbs/Cube_ABS_6m43s-350x350.png. Retrying in 6 seconds
2023-12-03 11:05:42,420 [files.py:_callback()] - Error in getting metadata for .thumbs/Cube_ABS_6m43s-32x32.png. Retrying in 6 seconds
2023-12-03 11:05:42,584 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-12-03 11:05:42,585 [printer.py:change_state()] - Adding callback for state: printing
2023-12-03 11:05:42,621 [screen.py:_load_panel()] - Loading panel: job_status
2023-12-03 11:05:42,870 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-12-03 11:05:42,881 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-12-03 11:05:42,909 [job_status.py:update_file_metadata()] - Update Metadata. File: Cube_ABS_6m43s.gcode Size: 100027
2023-12-03 11:05:42,924 [job_status.py:show_file_thumbnail()] - Cube_ABS_6m43s.gcode
2023-12-03 11:27:54,051 [printer.py:change_state()] - Changing state from 'printing' to 'shutdown'
2023-12-03 11:27:54,051 [printer.py:change_state()] - Adding callback for state: shutdown
2023-12-03 11:27:54,095 [screen.py:show_panel()] - Reinitializing panel
2023-12-03 11:27:54,164 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-12-03 11:28:34,800 [printer.py:change_state()] - Changing state from 'shutdown' to 'disconnected'
2023-12-03 11:28:34,801 [printer.py:change_state()] - Adding callback for state: disconnected
2023-12-03 11:28:34,804 [screen.py:state_disconnected()] - ### Going to disconnected
2023-12-03 11:28:34,809 [screen.py:show_panel()] - Reinitializing panel
2023-12-03 11:28:34,937 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-12-03 11:28:38,152 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-03 11:28:38,170 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-03 11:28:38,171 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'history', 'octoprint_compat', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 3, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-03 11:28:38,188 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-03 11:28:38,190 [printer.py:configure_cameras()] - Cameras: []
2023-12-03 11:28:38,209 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-12-03 11:28:38,256 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-12-03 11:28:38,260 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.66', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.84', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'skew_correction': {}, 'bed_mesh default': {'version': '1', 'points': '\n-0.076250, -0.090625, -0.085000\n-0.095625, -0.118750, -0.112500\n-0.044375, -0.082500, -0.095625', 'x_count': '3', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '120.00000000000001', 'max_x': '230.0', 'min_y': '120.0', 'max_y': '230.0'}, 'skew_correction my_skew_profile': {'xy_skew': '0.0', 'xz_skew': '0.0', 'yz_skew': '0.0'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[-0.07625, -0.090625, -0.085], [-0.095625, -0.11875, -0.1125], [-0.044375, -0.0825, -0.095625]], 'min_x': 120.00000000000001, 'max_x': 230.0, 'min_y': 120.0, 'max_y': 230.0, 'x_count': 3, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.66, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.84, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'skew_correction my_skew_profile': {'xy_skew': 0.0, 'xz_skew': 0.0, 'yz_skew': 0.0}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-12-03 11:28:38,267 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-12-03 11:28:38,268 [printer.py:reinit()] - # Extruders: 1
2023-12-03 11:28:38,268 [printer.py:reinit()] - # Temperature devices: 5
2023-12-03 11:28:38,268 [printer.py:reinit()] - # Fans: 2
2023-12-03 11:28:38,268 [printer.py:reinit()] - # Output pins: 1
2023-12-03 11:28:38,269 [printer.py:reinit()] - # Leds: 0
2023-12-03 11:28:38,290 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-12-03 11:28:38,293 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-12-03 11:28:38,562 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-12-03 11:28:38,613 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-12-03 11:28:38,623 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-12-03 11:28:38,643 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-12-03 11:28:38,645 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-12-03 11:28:38,646 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-12-03 11:28:38,646 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-12-03 11:28:38,647 [screen.py:init_printer()] - Printer initialized
2023-12-03 11:28:38,648 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-12-03 11:28:38,649 [printer.py:change_state()] - Adding callback for state: startup
2023-12-03 11:29:19,188 [printer.py:change_state()] - Changing state from 'startup' to 'disconnected'
2023-12-03 11:29:19,189 [printer.py:change_state()] - Adding callback for state: disconnected
2023-12-03 11:29:19,191 [screen.py:state_disconnected()] - ### Going to disconnected
2023-12-03 11:29:19,194 [screen.py:show_panel()] - Reinitializing panel
2023-12-03 11:29:19,289 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-12-03 11:29:22,152 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-03 11:29:22,169 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-03 11:29:22,171 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'history', 'octoprint_compat', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 3, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-03 11:29:22,188 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-03 11:29:22,190 [printer.py:configure_cameras()] - Cameras: []
2023-12-03 11:29:22,209 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-12-03 11:29:22,245 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-12-03 11:29:22,249 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.66', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.84', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'skew_correction': {}, 'bed_mesh default': {'version': '1', 'points': '\n-0.076250, -0.090625, -0.085000\n-0.095625, -0.118750, -0.112500\n-0.044375, -0.082500, -0.095625', 'x_count': '3', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '120.00000000000001', 'max_x': '230.0', 'min_y': '120.0', 'max_y': '230.0'}, 'skew_correction my_skew_profile': {'xy_skew': '0.0', 'xz_skew': '0.0', 'yz_skew': '0.0'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[-0.07625, -0.090625, -0.085], [-0.095625, -0.11875, -0.1125], [-0.044375, -0.0825, -0.095625]], 'min_x': 120.00000000000001, 'max_x': 230.0, 'min_y': 120.0, 'max_y': 230.0, 'x_count': 3, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.66, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.84, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'skew_correction my_skew_profile': {'xy_skew': 0.0, 'xz_skew': 0.0, 'yz_skew': 0.0}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-12-03 11:29:22,256 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-12-03 11:29:22,256 [printer.py:reinit()] - # Extruders: 1
2023-12-03 11:29:22,256 [printer.py:reinit()] - # Temperature devices: 5
2023-12-03 11:29:22,256 [printer.py:reinit()] - # Fans: 2
2023-12-03 11:29:22,257 [printer.py:reinit()] - # Output pins: 1
2023-12-03 11:29:22,257 [printer.py:reinit()] - # Leds: 0
2023-12-03 11:29:22,279 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-12-03 11:29:22,282 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-12-03 11:29:22,564 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-12-03 11:29:22,615 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-12-03 11:29:22,625 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-12-03 11:29:22,645 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-12-03 11:29:22,647 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-12-03 11:29:22,648 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-12-03 11:29:22,648 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-12-03 11:29:22,649 [screen.py:init_printer()] - Printer initialized
2023-12-03 11:29:22,650 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-12-03 11:29:22,651 [printer.py:change_state()] - Adding callback for state: startup
--------------------KlipperScreen Log Start--------------------
Git Version: v0.3.6-65-g4a14962
2023-12-03 11:17:22,230 [screen.py:main()] - Python version: 3.9
2023-12-03 11:17:22,231 [screen.py:main()] - KlipperScreen version: v0.3.6-65-g4a14962
2023-12-03 11:17:22,248 [functions.py:detect_desktop_environment()] - Error:
'XDG_CURRENT_DESKTOP'

Traceback (most recent call last):
  File "/home/biqu/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.9/os.py", line 679, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
Traceback (most recent call last):
  File "/home/biqu/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.9/os.py", line 679, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
2023-12-03 11:17:22,549 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-12-03 11:17:22,551 [config.py:__init__()] - Config path location: /home/biqu/printer_data/config/KlipperScreen.conf
2023-12-03 11:17:22,590 [config.py:log_config()] -  ===== Config File =====

=======================
2023-12-03 11:17:22,594 [config.py:__init__()] - ====== Saved Def ======

[main]
print_sort_dir = date_asc

[graph Printer]
extruder = False

=======================
2023-12-03 11:17:22,596 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-12-03 11:17:22,718 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-12-03 11:17:22,719 [config.py:install_language()] - Using system lang
2023-12-03 11:17:22,720 [config.py:install_language()] - Using lang en
2023-12-03 11:17:22,752 [screen.py:__init__()] - Screen resolution: 800x480
2023-12-03 11:17:22,756 [KlippyGtk.py:__init__()] - Font size: 16.6 (medium)
2023-12-03 11:17:25,131 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-12-03 11:17:25,154 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-12-03 11:17:25,169 [screen.py:initial_connection()] - Default printer: None
2023-12-03 11:17:25,170 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-12-03 11:17:25,171 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-12-03 11:17:25,279 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-12-03 11:17:25,315 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-12-03 11:17:25,369 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-03 11:17:25,398 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-12-03 11:17:25,402 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-12-03 11:17:25,426 [_logging.py:info()] - Websocket connected
2023-12-03 11:17:25,427 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-12-03 11:17:25,890 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-03 11:17:25,914 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-03 11:17:25,916 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'history', 'authorization', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-03 11:17:25,955 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-03 11:17:25,958 [printer.py:configure_cameras()] - Cameras: []
2023-12-03 11:17:25,960 [screen.py:init_printer()] - Klipper not connected
2023-12-03 11:17:29,727 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-03 11:17:29,749 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-03 11:17:29,751 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'history', 'authorization', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-03 11:17:29,771 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-03 11:17:29,773 [printer.py:configure_cameras()] - Cameras: []
2023-12-03 11:17:29,773 [screen.py:init_printer()] - Klipper not connected
2023-12-03 11:17:32,042 [screen.py:_go_to_submenu()] - #### Go to submenu 
2023-12-03 11:17:32,043 [screen.py:_go_to_submenu()] - #### Menu __splashscreen
2023-12-03 11:17:32,047 [screen.py:_load_panel()] - Loading panel: menu
2023-12-03 11:17:32,065 [menu.py:evaluate_enable()] - moonraker connected True
2023-12-03 11:17:32,152 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen > 
2023-12-03 11:17:32,159 [menu.py:arrangeMenuItems()] - X > power
2023-12-03 11:17:32,163 [menu.py:evaluate_enable()] - moonraker connected True
2023-12-03 11:17:32,735 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-03 11:17:32,756 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-03 11:17:32,759 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'history', 'authorization', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-03 11:17:32,781 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-03 11:17:32,785 [printer.py:configure_cameras()] - Cameras: []
2023-12-03 11:17:32,830 [KlippyRest.py:_do_request()] - 404 Client Error>>Not Found for url>>http://127.0.0.1:7125/printer/info
2023-12-03 11:17:33,922 [screen.py:_menu_go_back()] - #### Menu go back
2023-12-03 11:17:33,950 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-12-03 11:17:35,723 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-03 11:17:35,741 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-03 11:17:35,743 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'octoprint_compat', 'history', 'authorization', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-03 11:17:35,760 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-03 11:17:35,761 [printer.py:configure_cameras()] - Cameras: []
2023-12-03 11:17:35,781 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-12-03 11:17:35,904 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-12-03 11:17:35,912 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.66', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.84', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'skew_correction': {}, 'bed_mesh default': {'version': '1', 'points': '\n-0.076250, -0.090625, -0.085000\n-0.095625, -0.118750, -0.112500\n-0.044375, -0.082500, -0.095625', 'x_count': '3', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '120.00000000000001', 'max_x': '230.0', 'min_y': '120.0', 'max_y': '230.0'}, 'skew_correction my_skew_profile': {'xy_skew': '0.0', 'xz_skew': '0.0', 'yz_skew': '0.0'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[-0.07625, -0.090625, -0.085], [-0.095625, -0.11875, -0.1125], [-0.044375, -0.0825, -0.095625]], 'min_x': 120.00000000000001, 'max_x': 230.0, 'min_y': 120.0, 'max_y': 230.0, 'x_count': 3, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.66, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.84, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'skew_correction my_skew_profile': {'xy_skew': 0.0, 'xz_skew': 0.0, 'yz_skew': 0.0}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-12-03 11:17:35,924 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-12-03 11:17:35,924 [printer.py:reinit()] - # Extruders: 1
2023-12-03 11:17:35,925 [printer.py:reinit()] - # Temperature devices: 5
2023-12-03 11:17:35,925 [printer.py:reinit()] - # Fans: 2
2023-12-03 11:17:35,926 [printer.py:reinit()] - # Output pins: 1
2023-12-03 11:17:35,926 [printer.py:reinit()] - # Leds: 0
2023-12-03 11:17:35,964 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-12-03 11:17:35,969 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-12-03 11:17:36,227 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-12-03 11:17:36,248 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-12-03 11:17:36,249 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-12-03 11:17:36,250 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-12-03 11:17:36,251 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-12-03 11:17:36,252 [screen.py:init_printer()] - Printer initialized
2023-12-03 11:17:36,253 [printer.py:change_state()] - Changing state from 'disconnected' to 'ready'
2023-12-03 11:17:36,253 [printer.py:change_state()] - Adding callback for state: ready
2023-12-03 11:17:36,261 [screen.py:_load_panel()] - Loading panel: main_menu
2023-12-03 11:17:36,405 [main_menu.py:__init__()] - ### Making MainMenu
2023-12-03 11:17:36,418 [main_menu.py:add_device()] - Adding device: extruder
2023-12-03 11:17:36,429 [main_menu.py:add_device()] - Adding device: heater_bed
2023-12-03 11:17:36,439 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-12-03 11:17:36,449 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-12-03 11:17:36,459 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-12-03 11:17:36,469 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-12-03 11:17:36,535 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-12-03 11:17:36,538 [main_menu.py:update_graph_visibility()] - Could not create graph tempstore: []
2023-12-03 11:17:38,489 [screen.py:_load_panel()] - Loading panel: move
2023-12-03 11:17:38,640 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > move
2023-12-03 11:17:41,322 [screen.py:_menu_go_back()] - #### Menu go back
2023-12-03 11:17:41,376 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-12-03 11:17:41,378 [main_menu.py:update_graph_visibility()] - Could not create graph tempstore: []
2023-12-03 11:17:41,726 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-12-03 11:17:41,755 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-12-03 11:17:41,777 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-12-03 11:17:41,780 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-12-03 11:17:42,799 [screen.py:_load_panel()] - Loading panel: gcode_macros
2023-12-03 11:17:42,922 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > gcode_macros
2023-12-03 11:17:54,692 [screen.py:show_popup_message()] - echo: FAKE_POSITION 
2023-12-03 11:17:54,705 [screen.py:_send_action()] - printer.gcode.script: {'script': 'FAKE_POSITION'}
2023-12-03 11:17:57,714 [screen.py:_menu_go_back()] - #### Menu go back
2023-12-03 11:17:57,776 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-12-03 11:17:59,628 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > move
2023-12-03 11:18:01,772 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G91\nG0 Z+25 F600'}
2023-12-03 11:18:01,778 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: G90
2023-12-03 11:31:21,603 [files.py:_callback()] - Error in getting metadata for .thumbs/Cube_ABS_6m42s-350x350.png. Retrying in 6 seconds
2023-12-03 11:31:21,610 [files.py:_callback()] - Error in getting metadata for .thumbs/Cube_ABS_6m42s-32x32.png. Retrying in 6 seconds
2023-12-03 11:31:21,616 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-12-03 11:31:21,616 [printer.py:change_state()] - Adding callback for state: printing
2023-12-03 11:31:21,634 [screen.py:_load_panel()] - Loading panel: job_status
2023-12-03 11:31:21,871 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-12-03 11:31:21,882 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-12-03 11:31:21,909 [job_status.py:update_file_metadata()] - Cannot find file metadata. Listening for updated metadata
2023-12-03 11:31:21,909 [job_status.py:show_file_thumbnail()] - Cube_ABS_6m42s.gcode
2023-12-03 11:31:21,910 [job_status.py:show_file_thumbnail()] - no pixbuf
2023-12-03 11:31:22,077 [job_status.py:update_file_metadata()] - Update Metadata. File: Cube_ABS_6m42s.gcode Size: 68928
2023-12-03 11:31:22,094 [job_status.py:show_file_thumbnail()] - Cube_ABS_6m42s.gcode
2023-12-03 11:44:20,822 [job_status.py:set_state()] - Changing job_status state from 'printing' to 'complete'
2023-12-03 11:44:25,067 [printer.py:change_state()] - Changing state from 'printing' to 'ready'
2023-12-03 11:44:25,067 [printer.py:change_state()] - Adding callback for state: ready
2023-12-03 11:59:35,895 [files.py:_callback()] - Error in getting metadata for .thumbs/flowrate_0_ABS_47m5s-350x350.png. Retrying in 6 seconds
2023-12-03 11:59:35,899 [files.py:_callback()] - Error in getting metadata for .thumbs/flowrate_0_ABS_47m5s-32x32.png. Retrying in 6 seconds
2023-12-03 11:59:35,919 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-12-03 11:59:35,920 [printer.py:change_state()] - Adding callback for state: printing
2023-12-03 11:59:35,939 [job_status.py:set_state()] - Changing job_status state from 'complete' to 'printing'
2023-12-03 11:59:35,949 [job_status.py:update_file_metadata()] - Cannot find file metadata. Listening for updated metadata
2023-12-03 11:59:35,949 [job_status.py:show_file_thumbnail()] - flowrate_0_ABS_47m5s.gcode
2023-12-03 11:59:35,950 [job_status.py:show_file_thumbnail()] - no pixbuf
2023-12-03 11:59:36,009 [screen.py:show_panel()] - Reinitializing panel
2023-12-03 11:59:36,223 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-12-03 11:59:36,234 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-12-03 11:59:36,248 [job_status.py:update_file_metadata()] - Cannot find file metadata. Listening for updated metadata
2023-12-03 11:59:36,249 [job_status.py:show_file_thumbnail()] - flowrate_0_ABS_47m5s.gcode
2023-12-03 11:59:36,249 [job_status.py:show_file_thumbnail()] - no pixbuf
2023-12-03 11:59:36,325 [job_status.py:update_file_metadata()] - Update Metadata. File: flowrate_0_ABS_47m5s.gcode Size: 644163
2023-12-03 11:59:36,336 [job_status.py:show_file_thumbnail()] - flowrate_0_ABS_47m5s.gcode
2023-12-03 12:30:38,723 [screen.py:show_screensaver()] - Showing Screensaver
2023-12-03 12:51:42,482 [screen.py:close_screensaver()] - Closing Screensaver
2023-12-03 12:51:42,512 [screen.py:wake_screen()] - Screen wake up
2023-12-03 12:51:42,566 [job_status.py:set_state()] - Changing job_status state from 'printing' to 'complete'
2023-12-03 12:51:47,233 [printer.py:change_state()] - Changing state from 'printing' to 'ready'
2023-12-03 12:51:47,234 [printer.py:change_state()] - Adding callback for state: ready
2023-12-03 13:51:42,725 [screen.py:show_screensaver()] - Showing Screensaver
2023-12-03 14:25:22,829 [files.py:_callback()] - Error in getting metadata for .thumbs/flowrate_0_ABS_52m8s-350x350.png. Retrying in 6 seconds
2023-12-03 14:25:22,835 [files.py:_callback()] - Error in getting metadata for .thumbs/flowrate_0_ABS_52m8s-32x32.png. Retrying in 6 seconds
2023-12-03 14:25:23,022 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-12-03 14:25:23,023 [printer.py:change_state()] - Adding callback for state: printing
2023-12-03 14:25:23,033 [job_status.py:set_state()] - Changing job_status state from 'complete' to 'printing'
2023-12-03 14:25:23,035 [job_status.py:update_file_metadata()] - Update Metadata. File: flowrate_0_ABS_52m8s.gcode Size: 699320
2023-12-03 14:25:23,045 [job_status.py:show_file_thumbnail()] - flowrate_0_ABS_52m8s.gcode
2023-12-03 14:25:23,051 [screen.py:close_screensaver()] - Closing Screensaver
2023-12-03 14:25:23,077 [screen.py:wake_screen()] - Screen wake up
2023-12-03 14:25:23,136 [screen.py:show_panel()] - Reinitializing panel
2023-12-03 14:25:23,372 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-12-03 14:25:23,383 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-12-03 14:25:23,397 [job_status.py:update_file_metadata()] - Update Metadata. File: flowrate_0_ABS_52m8s.gcode Size: 699320
2023-12-03 14:25:23,407 [job_status.py:show_file_thumbnail()] - flowrate_0_ABS_52m8s.gcode
2023-12-03 15:25:23,726 [screen.py:show_screensaver()] - Showing Screensaver
2023-12-03 15:35:31,397 [screen.py:close_screensaver()] - Closing Screensaver
2023-12-03 15:35:31,423 [screen.py:wake_screen()] - Screen wake up
2023-12-03 15:35:31,477 [job_status.py:set_state()] - Changing job_status state from 'printing' to 'complete'
2023-12-03 15:35:37,662 [printer.py:change_state()] - Changing state from 'printing' to 'ready'
2023-12-03 15:35:37,663 [printer.py:change_state()] - Adding callback for state: ready
2023-12-03 16:35:31,723 [screen.py:show_screensaver()] - Showing Screensaver
--------------------KlipperScreen Log Start--------------------
Git Version: v0.3.6-65-g4a14962
2023-12-03 21:17:21,497 [screen.py:main()] - Python version: 3.9
2023-12-03 21:17:21,498 [screen.py:main()] - KlipperScreen version: v0.3.6-65-g4a14962
2023-12-03 21:17:21,506 [functions.py:detect_desktop_environment()] - Error:
'XDG_CURRENT_DESKTOP'

Traceback (most recent call last):
  File "/home/biqu/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.9/os.py", line 679, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
Traceback (most recent call last):
  File "/home/biqu/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.9/os.py", line 679, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
2023-12-03 21:17:21,791 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-12-03 21:17:21,794 [config.py:__init__()] - Config path location: /home/biqu/printer_data/config/KlipperScreen.conf
2023-12-03 21:17:21,831 [config.py:log_config()] -  ===== Config File =====

=======================
2023-12-03 21:17:21,835 [config.py:__init__()] - ====== Saved Def ======

[main]
print_sort_dir = date_asc

[graph Printer]
extruder = False

=======================
2023-12-03 21:17:21,836 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-12-03 21:17:21,940 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-12-03 21:17:21,940 [config.py:install_language()] - Using system lang
2023-12-03 21:17:21,941 [config.py:install_language()] - Using lang en
2023-12-03 21:17:21,975 [screen.py:__init__()] - Screen resolution: 800x480
2023-12-03 21:17:21,979 [KlippyGtk.py:__init__()] - Font size: 16.6 (medium)
2023-12-03 21:17:23,529 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-12-03 21:17:23,543 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-12-03 21:17:23,554 [screen.py:initial_connection()] - Default printer: None
2023-12-03 21:17:23,554 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-12-03 21:17:23,555 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-12-03 21:17:23,654 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-12-03 21:17:23,670 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-12-03 21:17:23,706 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-03 21:17:23,727 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-12-03 21:17:23,729 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-12-03 21:17:23,745 [_logging.py:info()] - Websocket connected
2023-12-03 21:17:23,745 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-12-03 21:17:24,031 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-03 21:17:24,053 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-03 21:17:24,055 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'history', 'octoprint_compat', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-03 21:17:24,075 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-03 21:17:24,076 [printer.py:configure_cameras()] - Cameras: []
2023-12-03 21:17:24,077 [screen.py:init_printer()] - Klipper not connected
2023-12-03 21:17:27,115 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-03 21:17:27,142 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-03 21:17:27,145 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'history', 'octoprint_compat', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-03 21:17:27,173 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-03 21:17:27,175 [printer.py:configure_cameras()] - Cameras: []
2023-12-03 21:17:27,176 [screen.py:init_printer()] - Klipper not connected
2023-12-03 21:17:30,042 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-03 21:17:30,062 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-03 21:17:30,064 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'history', 'octoprint_compat', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 3, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-03 21:17:30,084 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-03 21:17:30,086 [printer.py:configure_cameras()] - Cameras: []
2023-12-03 21:17:30,120 [KlippyRest.py:_do_request()] - 404 Client Error>>Not Found for url>>http://127.0.0.1:7125/printer/info
2023-12-03 21:17:33,040 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-03 21:17:33,057 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-03 21:17:33,059 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'authorization', 'history', 'octoprint_compat', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 3, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-03 21:17:33,078 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-03 21:17:33,080 [printer.py:configure_cameras()] - Cameras: []
2023-12-03 21:17:33,100 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-12-03 21:17:33,133 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-12-03 21:17:33,138 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.66', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.84', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'skew_correction': {}, 'bed_mesh default': {'version': '1', 'points': '\n-0.076250, -0.090625, -0.085000\n-0.095625, -0.118750, -0.112500\n-0.044375, -0.082500, -0.095625', 'x_count': '3', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '120.00000000000001', 'max_x': '230.0', 'min_y': '120.0', 'max_y': '230.0'}, 'skew_correction my_skew_profile': {'xy_skew': '0.0', 'xz_skew': '0.0', 'yz_skew': '0.0'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[-0.07625, -0.090625, -0.085], [-0.095625, -0.11875, -0.1125], [-0.044375, -0.0825, -0.095625]], 'min_x': 120.00000000000001, 'max_x': 230.0, 'min_y': 120.0, 'max_y': 230.0, 'x_count': 3, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.66, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.84, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'skew_correction my_skew_profile': {'xy_skew': 0.0, 'xz_skew': 0.0, 'yz_skew': 0.0}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-12-03 21:17:33,143 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-12-03 21:17:33,143 [printer.py:reinit()] - # Extruders: 1
2023-12-03 21:17:33,144 [printer.py:reinit()] - # Temperature devices: 5
2023-12-03 21:17:33,144 [printer.py:reinit()] - # Fans: 2
2023-12-03 21:17:33,144 [printer.py:reinit()] - # Output pins: 1
2023-12-03 21:17:33,145 [printer.py:reinit()] - # Leds: 0
2023-12-03 21:17:33,170 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-12-03 21:17:33,173 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-12-03 21:17:33,440 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-12-03 21:17:33,498 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-12-03 21:17:33,501 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-12-03 21:17:33,503 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-12-03 21:17:33,503 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-12-03 21:17:33,506 [screen.py:init_printer()] - Printer initialized
2023-12-03 21:17:33,507 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-12-03 21:17:33,508 [printer.py:change_state()] - Adding callback for state: startup
2023-12-03 21:17:34,883 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-12-03 21:17:34,884 [printer.py:change_state()] - Adding callback for state: ready
2023-12-03 21:17:34,889 [screen.py:_load_panel()] - Loading panel: main_menu
2023-12-03 21:17:35,035 [main_menu.py:__init__()] - ### Making MainMenu
2023-12-03 21:17:35,049 [main_menu.py:add_device()] - Adding device: extruder
2023-12-03 21:17:35,060 [main_menu.py:add_device()] - Adding device: heater_bed
2023-12-03 21:17:35,072 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-12-03 21:17:35,082 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-12-03 21:17:35,092 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-12-03 21:17:35,102 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-12-03 21:17:35,181 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-12-03 21:17:35,186 [main_menu.py:update_graph_visibility()] - Could not create graph tempstore: []
2023-12-03 21:17:39,054 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-12-03 21:17:39,123 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-12-03 21:17:39,165 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-12-03 21:17:39,168 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-12-05 19:05:06,292 [files.py:_callback()] - Error in getting metadata for .thumbs/pressure_advance_test_ABS_3m47s-350x350.png. Retrying in 6 seconds
2023-12-05 19:05:06,296 [files.py:_callback()] - Error in getting metadata for .thumbs/pressure_advance_test_ABS_3m47s-32x32.png. Retrying in 6 seconds
2023-12-05 19:05:06,439 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-12-05 19:05:06,439 [printer.py:change_state()] - Adding callback for state: printing
2023-12-05 19:05:06,478 [screen.py:_load_panel()] - Loading panel: job_status
2023-12-05 19:05:06,730 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-12-05 19:05:06,740 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-12-05 19:05:06,766 [job_status.py:update_file_metadata()] - Update Metadata. File: pressure_advance_test_ABS_3m47s.gcode Size: 48254
2023-12-05 19:05:06,780 [job_status.py:show_file_thumbnail()] - pressure_advance_test_ABS_3m47s.gcode
2023-12-05 19:30:59,820 [job_status.py:set_state()] - Changing job_status state from 'printing' to 'complete'
2023-12-05 19:31:02,555 [printer.py:change_state()] - Changing state from 'printing' to 'ready'
2023-12-05 19:31:02,555 [printer.py:change_state()] - Adding callback for state: ready
2023-12-05 20:03:26,581 [screen.py:show_screensaver()] - Showing Screensaver
--------------------KlipperScreen Log Start--------------------
Git Version: v0.3.6-65-g4a14962
2023-12-05 21:17:23,032 [screen.py:main()] - Python version: 3.9
2023-12-05 21:17:23,033 [screen.py:main()] - KlipperScreen version: v0.3.6-65-g4a14962
2023-12-05 21:17:23,042 [functions.py:detect_desktop_environment()] - Error:
'XDG_CURRENT_DESKTOP'

Traceback (most recent call last):
  File "/home/biqu/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.9/os.py", line 679, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
Traceback (most recent call last):
  File "/home/biqu/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.9/os.py", line 679, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
2023-12-05 21:17:23,360 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-12-05 21:17:23,362 [config.py:__init__()] - Config path location: /home/biqu/printer_data/config/KlipperScreen.conf
2023-12-05 21:17:23,406 [config.py:log_config()] -  ===== Config File =====

=======================
2023-12-05 21:17:23,417 [config.py:__init__()] - ====== Saved Def ======

[main]
print_sort_dir = date_asc

[graph Printer]
extruder = False

=======================
2023-12-05 21:17:23,419 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-12-05 21:17:23,584 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-12-05 21:17:23,586 [config.py:install_language()] - Using system lang
2023-12-05 21:17:23,587 [config.py:install_language()] - Using lang en
2023-12-05 21:17:23,637 [screen.py:__init__()] - Screen resolution: 800x480
2023-12-05 21:17:23,643 [KlippyGtk.py:__init__()] - Font size: 16.6 (medium)
2023-12-05 21:17:25,468 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-12-05 21:17:25,486 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-12-05 21:17:25,500 [screen.py:initial_connection()] - Default printer: None
2023-12-05 21:17:25,501 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-12-05 21:17:25,502 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-12-05 21:17:25,595 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-12-05 21:17:25,616 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-12-05 21:17:25,655 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-05 21:17:25,681 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-12-05 21:17:25,684 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-12-05 21:17:25,703 [_logging.py:info()] - Websocket connected
2023-12-05 21:17:25,704 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-12-05 21:17:26,063 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-05 21:17:26,090 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-05 21:17:26,092 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'authorization', 'update_manager', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-05 21:17:26,116 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-05 21:17:26,118 [printer.py:configure_cameras()] - Cameras: []
2023-12-05 21:17:26,119 [screen.py:init_printer()] - Klipper not connected
2023-12-05 21:17:29,027 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-05 21:17:29,049 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-05 21:17:29,050 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'authorization', 'update_manager', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-05 21:17:29,089 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-05 21:17:29,092 [printer.py:configure_cameras()] - Cameras: []
2023-12-05 21:17:29,092 [screen.py:init_printer()] - Klipper not connected
2023-12-05 21:17:32,024 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-05 21:17:32,043 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-05 21:17:32,045 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'authorization', 'update_manager', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-05 21:17:32,071 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-05 21:17:32,075 [printer.py:configure_cameras()] - Cameras: []
2023-12-05 21:17:32,185 [KlippyRest.py:_do_request()] - 404 Client Error>>Not Found for url>>http://127.0.0.1:7125/printer/info
2023-12-05 21:17:35,030 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-05 21:17:35,050 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-05 21:17:35,052 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'authorization', 'update_manager', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-05 21:17:35,072 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-05 21:17:35,075 [printer.py:configure_cameras()] - Cameras: []
2023-12-05 21:17:35,103 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-12-05 21:17:35,141 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-12-05 21:17:35,145 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.66', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.84', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'skew_correction': {}, 'bed_mesh default': {'version': '1', 'points': '\n-0.076250, -0.090625, -0.085000\n-0.095625, -0.118750, -0.112500\n-0.044375, -0.082500, -0.095625', 'x_count': '3', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '120.00000000000001', 'max_x': '230.0', 'min_y': '120.0', 'max_y': '230.0'}, 'skew_correction my_skew_profile': {'xy_skew': '0.0', 'xz_skew': '0.0', 'yz_skew': '0.0'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[-0.07625, -0.090625, -0.085], [-0.095625, -0.11875, -0.1125], [-0.044375, -0.0825, -0.095625]], 'min_x': 120.00000000000001, 'max_x': 230.0, 'min_y': 120.0, 'max_y': 230.0, 'x_count': 3, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.66, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.84, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'skew_correction my_skew_profile': {'xy_skew': 0.0, 'xz_skew': 0.0, 'yz_skew': 0.0}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-12-05 21:17:35,151 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-12-05 21:17:35,151 [printer.py:reinit()] - # Extruders: 1
2023-12-05 21:17:35,152 [printer.py:reinit()] - # Temperature devices: 5
2023-12-05 21:17:35,152 [printer.py:reinit()] - # Fans: 2
2023-12-05 21:17:35,152 [printer.py:reinit()] - # Output pins: 1
2023-12-05 21:17:35,152 [printer.py:reinit()] - # Leds: 0
2023-12-05 21:17:35,188 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-12-05 21:17:35,191 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-12-05 21:17:35,468 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-12-05 21:17:35,488 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-12-05 21:17:35,490 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-12-05 21:17:35,490 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-12-05 21:17:35,491 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-12-05 21:17:35,492 [screen.py:init_printer()] - Printer initialized
2023-12-05 21:17:35,493 [printer.py:change_state()] - Changing state from 'disconnected' to 'ready'
2023-12-05 21:17:35,493 [printer.py:change_state()] - Adding callback for state: ready
2023-12-05 21:17:35,501 [screen.py:_load_panel()] - Loading panel: main_menu
2023-12-05 21:17:35,652 [main_menu.py:__init__()] - ### Making MainMenu
2023-12-05 21:17:35,665 [main_menu.py:add_device()] - Adding device: extruder
2023-12-05 21:17:35,675 [main_menu.py:add_device()] - Adding device: heater_bed
2023-12-05 21:17:35,686 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-12-05 21:17:35,695 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-12-05 21:17:35,706 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-12-05 21:17:35,716 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-12-05 21:17:35,783 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-12-05 21:17:35,786 [main_menu.py:update_graph_visibility()] - Could not create graph tempstore: []
2023-12-05 21:17:41,023 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-12-05 21:17:41,052 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-12-05 21:17:41,075 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-12-05 21:17:41,077 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-12-15 10:11:06,681 [files.py:_callback()] - Error in getting metadata for .thumbs/Body1_ABS_5h37m-350x350.png. Retrying in 6 seconds
2023-12-15 10:11:06,685 [files.py:_callback()] - Error in getting metadata for .thumbs/Body1_ABS_5h37m-32x32.png. Retrying in 6 seconds
2023-12-15 10:11:06,706 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-12-15 10:11:06,707 [printer.py:change_state()] - Adding callback for state: printing
2023-12-15 10:11:06,745 [screen.py:_load_panel()] - Loading panel: job_status
2023-12-15 10:11:06,968 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-12-15 10:11:06,979 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-12-15 10:11:07,006 [job_status.py:update_file_metadata()] - Update Metadata. File: Body1_ABS_5h37m.gcode Size: 29698047
2023-12-15 10:11:07,021 [job_status.py:show_file_thumbnail()] - Body1_ABS_5h37m.gcode
2023-12-15 10:23:33,471 [printer.py:change_state()] - Changing state from 'printing' to 'shutdown'
2023-12-15 10:23:33,471 [printer.py:change_state()] - Adding callback for state: shutdown
2023-12-15 10:23:33,510 [screen.py:show_panel()] - Reinitializing panel
2023-12-15 10:23:33,580 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-12-15 10:23:40,215 [printer.py:change_state()] - Changing state from 'shutdown' to 'disconnected'
2023-12-15 10:23:40,216 [printer.py:change_state()] - Adding callback for state: disconnected
2023-12-15 10:23:40,218 [screen.py:state_disconnected()] - ### Going to disconnected
2023-12-15 10:23:40,221 [screen.py:show_panel()] - Reinitializing panel
2023-12-15 10:23:40,312 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-12-15 10:23:43,372 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-15 10:23:43,390 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-15 10:23:43,393 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'authorization', 'update_manager', 'octoprint_compat'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 3, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-15 10:23:43,409 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-15 10:23:43,411 [printer.py:configure_cameras()] - Cameras: []
2023-12-15 10:23:43,431 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-12-15 10:23:43,464 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-12-15 10:23:43,468 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.66', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.84', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'skew_correction': {}, 'bed_mesh default': {'version': '1', 'points': '\n-0.076250, -0.090625, -0.085000\n-0.095625, -0.118750, -0.112500\n-0.044375, -0.082500, -0.095625', 'x_count': '3', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '120.00000000000001', 'max_x': '230.0', 'min_y': '120.0', 'max_y': '230.0'}, 'skew_correction my_skew_profile': {'xy_skew': '0.0', 'xz_skew': '0.0', 'yz_skew': '0.0'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[-0.07625, -0.090625, -0.085], [-0.095625, -0.11875, -0.1125], [-0.044375, -0.0825, -0.095625]], 'min_x': 120.00000000000001, 'max_x': 230.0, 'min_y': 120.0, 'max_y': 230.0, 'x_count': 3, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.66, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.84, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'skew_correction my_skew_profile': {'xy_skew': 0.0, 'xz_skew': 0.0, 'yz_skew': 0.0}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-12-15 10:23:43,475 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-12-15 10:23:43,476 [printer.py:reinit()] - # Extruders: 1
2023-12-15 10:23:43,476 [printer.py:reinit()] - # Temperature devices: 5
2023-12-15 10:23:43,476 [printer.py:reinit()] - # Fans: 2
2023-12-15 10:23:43,477 [printer.py:reinit()] - # Output pins: 1
2023-12-15 10:23:43,477 [printer.py:reinit()] - # Leds: 0
2023-12-15 10:23:43,499 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-12-15 10:23:43,502 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-12-15 10:23:43,786 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-12-15 10:23:43,840 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-12-15 10:23:43,856 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-12-15 10:23:43,881 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-12-15 10:23:43,884 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-12-15 10:23:43,885 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-12-15 10:23:43,885 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-12-15 10:23:43,886 [screen.py:init_printer()] - Printer initialized
2023-12-15 10:23:43,888 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-12-15 10:23:43,888 [printer.py:change_state()] - Adding callback for state: startup
2023-12-15 10:23:44,956 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-12-15 10:23:44,957 [printer.py:change_state()] - Adding callback for state: ready
2023-12-15 10:23:44,963 [screen.py:show_panel()] - Reinitializing panel
2023-12-15 10:23:45,079 [main_menu.py:__init__()] - ### Making MainMenu
2023-12-15 10:23:45,098 [main_menu.py:add_device()] - Adding device: extruder
2023-12-15 10:23:45,108 [main_menu.py:add_device()] - Adding device: heater_bed
2023-12-15 10:23:45,118 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-12-15 10:23:45,128 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-12-15 10:23:45,138 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-12-15 10:23:45,148 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-12-15 10:23:45,219 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-12-15 10:23:53,878 [files.py:_callback()] - Error in getting metadata for .thumbs/Body1_ABS_4h14m-350x350.png. Retrying in 6 seconds
2023-12-15 10:23:53,882 [files.py:_callback()] - Error in getting metadata for .thumbs/Body1_ABS_4h14m-32x32.png. Retrying in 6 seconds
2023-12-15 10:23:53,989 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-12-15 10:23:53,990 [printer.py:change_state()] - Adding callback for state: printing
2023-12-15 10:23:54,014 [screen.py:show_panel()] - Reinitializing panel
2023-12-15 10:23:54,217 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-12-15 10:23:54,228 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-12-15 10:23:54,254 [job_status.py:update_file_metadata()] - Update Metadata. File: Body1_ABS_4h14m.gcode Size: 14065658
2023-12-15 10:23:54,265 [job_status.py:show_file_thumbnail()] - Body1_ABS_4h14m.gcode
2023-12-15 11:06:41,348 [screen.py:show_screensaver()] - Showing Screensaver
2023-12-15 14:35:38,885 [screen.py:close_screensaver()] - Closing Screensaver
2023-12-15 14:35:38,927 [screen.py:wake_screen()] - Screen wake up
2023-12-15 14:38:38,699 [job_status.py:set_state()] - Changing job_status state from 'printing' to 'complete'
2023-12-15 14:38:42,197 [printer.py:change_state()] - Changing state from 'printing' to 'ready'
2023-12-15 14:38:42,198 [printer.py:change_state()] - Adding callback for state: ready
2023-12-15 14:51:48,642 [KlippyWebsocket.py:print_start()] - Sending printer.print.start
2023-12-15 14:51:48,644 [job_status.py:restart()] - Starting print: Body1_ABS_4h14m.gcode
2023-12-15 14:51:48,805 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-12-15 14:51:48,806 [printer.py:change_state()] - Adding callback for state: printing
2023-12-15 14:51:48,819 [job_status.py:set_state()] - Changing job_status state from 'complete' to 'printing'
2023-12-15 14:51:48,867 [screen.py:show_panel()] - Reinitializing panel
2023-12-15 14:51:49,077 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-12-15 14:51:49,089 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-12-15 14:51:49,113 [job_status.py:update_file_metadata()] - Update Metadata. File: Body1_ABS_4h14m.gcode Size: 14065658
2023-12-15 14:51:49,125 [job_status.py:show_file_thumbnail()] - Body1_ABS_4h14m.gcode
2023-12-15 14:52:00,071 [KlippyWebsocket.py:emergency_stop()] - Sending printer.emergency_stop
2023-12-15 14:52:00,358 [printer.py:change_state()] - Changing state from 'printing' to 'shutdown'
2023-12-15 14:52:00,358 [printer.py:change_state()] - Adding callback for state: shutdown
2023-12-15 14:52:00,407 [screen.py:show_panel()] - Reinitializing panel
2023-12-15 14:52:00,514 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
--------------------KlipperScreen Log Start--------------------
Git Version: v0.3.6-65-g4a14962
2023-12-15 14:17:20,401 [screen.py:main()] - Python version: 3.9
2023-12-15 14:17:20,402 [screen.py:main()] - KlipperScreen version: v0.3.6-65-g4a14962
2023-12-15 14:17:20,431 [functions.py:detect_desktop_environment()] - Error:
'XDG_CURRENT_DESKTOP'

Traceback (most recent call last):
  File "/home/biqu/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.9/os.py", line 679, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
Traceback (most recent call last):
  File "/home/biqu/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.9/os.py", line 679, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
2023-12-15 14:17:20,826 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-12-15 14:17:20,829 [config.py:__init__()] - Config path location: /home/biqu/printer_data/config/KlipperScreen.conf
2023-12-15 14:17:20,873 [config.py:log_config()] -  ===== Config File =====

=======================
2023-12-15 14:17:20,877 [config.py:__init__()] - ====== Saved Def ======

[main]
print_sort_dir = date_asc

[graph Printer]
extruder = False

=======================
2023-12-15 14:17:20,880 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-12-15 14:17:21,119 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-12-15 14:17:21,120 [config.py:install_language()] - Using system lang
2023-12-15 14:17:21,121 [config.py:install_language()] - Using lang en
2023-12-15 14:17:21,166 [screen.py:__init__()] - Screen resolution: 800x480
2023-12-15 14:17:21,171 [KlippyGtk.py:__init__()] - Font size: 16.6 (medium)
2023-12-15 14:17:22,968 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-12-15 14:17:22,984 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-12-15 14:17:22,996 [screen.py:initial_connection()] - Default printer: None
2023-12-15 14:17:22,996 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-12-15 14:17:22,997 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-12-15 14:17:23,114 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-12-15 14:17:23,133 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-12-15 14:17:23,175 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-15 14:17:23,200 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-12-15 14:17:23,204 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-12-15 14:17:23,220 [_logging.py:info()] - Websocket connected
2023-12-15 14:17:23,221 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-12-15 14:17:23,540 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-15 14:17:23,563 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-15 14:17:23,566 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'octoprint_compat', 'authorization', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-15 14:17:23,588 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-15 14:17:23,590 [printer.py:configure_cameras()] - Cameras: []
2023-12-15 14:17:23,591 [screen.py:init_printer()] - Klipper not connected
2023-12-15 14:17:27,264 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-15 14:17:27,284 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-15 14:17:27,286 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'octoprint_compat', 'authorization', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-15 14:17:27,306 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-15 14:17:27,308 [printer.py:configure_cameras()] - Cameras: []
2023-12-15 14:17:27,309 [screen.py:init_printer()] - Klipper not connected
2023-12-15 14:17:30,268 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-15 14:17:30,291 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-15 14:17:30,293 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'octoprint_compat', 'authorization', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-15 14:17:30,329 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-15 14:17:30,331 [printer.py:configure_cameras()] - Cameras: []
2023-12-15 14:17:30,331 [screen.py:init_printer()] - Klipper not connected
2023-12-15 14:17:33,292 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-15 14:17:33,323 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-15 14:17:33,327 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'octoprint_compat', 'authorization', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-15 14:17:33,351 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-15 14:17:33,355 [printer.py:configure_cameras()] - Cameras: []
2023-12-15 14:17:33,394 [KlippyRest.py:_do_request()] - 404 Client Error>>Not Found for url>>http://127.0.0.1:7125/printer/info
2023-12-15 14:17:36,259 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-15 14:17:36,276 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-15 14:17:36,278 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'octoprint_compat', 'authorization', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 1, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-15 14:17:36,299 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-15 14:17:36,301 [printer.py:configure_cameras()] - Cameras: []
2023-12-15 14:17:36,332 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-12-15 14:17:36,581 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-12-15 14:17:36,586 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.66', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.84', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'skew_correction': {}, 'bed_mesh default': {'version': '1', 'points': '\n-0.076250, -0.090625, -0.085000\n-0.095625, -0.118750, -0.112500\n-0.044375, -0.082500, -0.095625', 'x_count': '3', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '120.00000000000001', 'max_x': '230.0', 'min_y': '120.0', 'max_y': '230.0'}, 'skew_correction my_skew_profile': {'xy_skew': '0.0', 'xz_skew': '0.0', 'yz_skew': '0.0'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[-0.07625, -0.090625, -0.085], [-0.095625, -0.11875, -0.1125], [-0.044375, -0.0825, -0.095625]], 'min_x': 120.00000000000001, 'max_x': 230.0, 'min_y': 120.0, 'max_y': 230.0, 'x_count': 3, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.66, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.84, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'skew_correction my_skew_profile': {'xy_skew': 0.0, 'xz_skew': 0.0, 'yz_skew': 0.0}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-12-15 14:17:36,592 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-12-15 14:17:36,592 [printer.py:reinit()] - # Extruders: 1
2023-12-15 14:17:36,593 [printer.py:reinit()] - # Temperature devices: 5
2023-12-15 14:17:36,593 [printer.py:reinit()] - # Fans: 2
2023-12-15 14:17:36,593 [printer.py:reinit()] - # Output pins: 1
2023-12-15 14:17:36,594 [printer.py:reinit()] - # Leds: 0
2023-12-15 14:17:36,616 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-12-15 14:17:36,620 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-12-15 14:17:36,926 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-12-15 14:17:36,953 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-12-15 14:17:36,955 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-12-15 14:17:36,956 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-12-15 14:17:36,957 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-12-15 14:17:36,958 [screen.py:init_printer()] - Printer initialized
2023-12-15 14:17:36,959 [printer.py:change_state()] - Changing state from 'disconnected' to 'ready'
2023-12-15 14:17:36,959 [printer.py:change_state()] - Adding callback for state: ready
2023-12-15 14:17:36,972 [screen.py:_load_panel()] - Loading panel: main_menu
2023-12-15 14:17:37,133 [main_menu.py:__init__()] - ### Making MainMenu
2023-12-15 14:17:37,150 [main_menu.py:add_device()] - Adding device: extruder
2023-12-15 14:17:37,165 [main_menu.py:add_device()] - Adding device: heater_bed
2023-12-15 14:17:37,180 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-12-15 14:17:37,193 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-12-15 14:17:37,206 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-12-15 14:17:37,221 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-12-15 14:17:37,293 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-12-15 14:17:37,296 [main_menu.py:update_graph_visibility()] - Could not create graph tempstore: []
2023-12-15 14:17:42,280 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-12-15 14:17:42,312 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-12-15 14:17:42,351 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-12-15 14:17:42,355 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-12-15 14:18:02,067 [screen.py:_load_panel()] - Loading panel: temperature
2023-12-15 14:18:02,111 [temperature.py:add_device()] - Adding device: extruder
2023-12-15 14:18:02,124 [temperature.py:add_device()] - Adding device: heater_bed
2023-12-15 14:18:02,138 [temperature.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-12-15 14:18:02,151 [temperature.py:add_device()] - Adding device: temperature_sensor MCU
2023-12-15 14:18:02,161 [temperature.py:add_device()] - Adding device: temperature_sensor SoC
2023-12-15 14:18:02,172 [temperature.py:add_device()] - Adding device: temperature_sensor chamber
2023-12-15 14:18:02,185 [temperature.py:select_heater()] - Selecting extruder
2023-12-15 14:18:02,187 [temperature.py:select_heater()] - Selecting heater_bed
2023-12-15 14:18:02,272 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > temperature
2023-12-15 14:18:08,985 [temperature.py:select_heater()] - Deselecting extruder
2023-12-15 14:18:10,282 [temperature.py:select_heater()] - Selecting extruder
2023-12-15 14:18:16,082 [temperature.py:verify_max_temp()] - 230/350
2023-12-15 14:18:16,082 [KlippyWebsocket.py:set_tool_temp()] - Sending set_tool_temp: M104 T0 S230
2023-12-15 15:42:44,535 [screen.py:_menu_go_back()] - #### Menu go back
2023-12-15 15:42:44,630 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-12-15 15:42:47,215 [main_menu.py:toggle_visibility()] - Graph show True: extruder
2023-12-15 15:42:51,209 [screen.py:_load_panel()] - Loading panel: extrude
2023-12-15 15:42:51,331 [screen.py:attach_panel()] - Current panel hierarchy: main_menu > extrude
2023-12-15 15:42:54,703 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: M83
2023-12-15 15:42:54,706 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G1 E+10 F120'}
2023-12-15 15:43:00,215 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: M83
2023-12-15 15:43:00,217 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G1 E+10 F120'}
2023-12-15 15:43:00,510 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: M83
2023-12-15 15:43:00,512 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G1 E+10 F120'}
2023-12-15 15:43:07,582 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: M83
2023-12-15 15:43:07,584 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G1 E+10 F120'}
2023-12-15 15:43:09,087 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: M83
2023-12-15 15:43:09,088 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G1 E+10 F120'}
2023-12-15 15:43:09,334 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: M83
2023-12-15 15:43:09,336 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G1 E+10 F120'}
2023-12-15 15:43:22,798 [extrude.py:change_distance()] - ### Distance 25
2023-12-15 15:43:23,718 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: M83
2023-12-15 15:43:23,720 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G1 E+25 F120'}
2023-12-15 15:43:39,318 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: M83
2023-12-15 15:43:39,321 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G1 E+25 F120'}
2023-12-15 15:43:39,822 [KlippyWebsocket.py:gcode_script()] - Sending printer.gcode.script: M83
2023-12-15 15:43:39,823 [screen.py:_send_action()] - printer.gcode.script: {'script': 'G1 E+25 F120'}
2023-12-15 15:43:54,118 [screen.py:_menu_go_back()] - #### Menu go back
2023-12-15 15:43:54,222 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-12-15 15:43:58,718 [main_menu.py:verify_max_temp()] - 0/350
2023-12-15 15:43:58,719 [KlippyWebsocket.py:set_tool_temp()] - Sending set_tool_temp: M104 T0 S0
2023-12-15 15:47:23,690 [files.py:_callback()] - Error in getting metadata for .thumbs/Body1_ABS_6h20m-350x350.png. Retrying in 6 seconds
2023-12-15 15:47:23,693 [files.py:_callback()] - Error in getting metadata for .thumbs/Body1_ABS_6h20m-32x32.png. Retrying in 6 seconds
2023-12-15 15:47:23,928 [printer.py:change_state()] - Changing state from 'ready' to 'printing'
2023-12-15 15:47:23,929 [printer.py:change_state()] - Adding callback for state: printing
2023-12-15 15:47:23,955 [screen.py:_load_panel()] - Loading panel: job_status
2023-12-15 15:47:24,233 [screen.py:attach_panel()] - Current panel hierarchy: job_status
2023-12-15 15:47:24,245 [job_status.py:set_state()] - Changing job_status state from 'standby' to 'printing'
2023-12-15 15:47:24,265 [job_status.py:update_file_metadata()] - Update Metadata. File: Body1_ABS_6h20m.gcode Size: 29809021
2023-12-15 15:47:24,295 [job_status.py:show_file_thumbnail()] - Body1_ABS_6h20m.gcode
2023-12-15 16:43:59,036 [screen.py:show_screensaver()] - Showing Screensaver
2023-12-15 21:48:10,132 [screen.py:close_screensaver()] - Closing Screensaver
2023-12-15 21:48:10,156 [screen.py:wake_screen()] - Screen wake up
2023-12-15 22:11:39,089 [job_status.py:set_state()] - Changing job_status state from 'printing' to 'complete'
2023-12-15 22:11:45,592 [printer.py:change_state()] - Changing state from 'printing' to 'ready'
2023-12-15 22:11:45,593 [printer.py:change_state()] - Adding callback for state: ready
2023-12-15 22:12:47,025 [printer.py:change_state()] - Changing state from 'ready' to 'shutdown'
2023-12-15 22:12:47,025 [printer.py:change_state()] - Adding callback for state: shutdown
2023-12-15 22:12:47,063 [screen.py:show_panel()] - Reinitializing panel
2023-12-15 22:12:47,144 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-12-15 22:48:11,036 [screen.py:show_screensaver()] - Showing Screensaver
--------------------KlipperScreen Log Start--------------------
Git Version: v0.3.6-65-g4a14962
2023-12-15 23:17:20,727 [screen.py:main()] - Python version: 3.9
2023-12-15 23:17:20,727 [screen.py:main()] - KlipperScreen version: v0.3.6-65-g4a14962
2023-12-15 23:17:20,755 [functions.py:detect_desktop_environment()] - Error:
'XDG_CURRENT_DESKTOP'

Traceback (most recent call last):
  File "/home/biqu/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.9/os.py", line 679, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
Traceback (most recent call last):
  File "/home/biqu/KlipperScreen/ks_includes/functions.py", line 191, in detect_desktop_environment
    env = os.environ['XDG_CURRENT_DESKTOP']
  File "/usr/lib/python3.9/os.py", line 679, in __getitem__
    raise KeyError(key) from None
KeyError: 'XDG_CURRENT_DESKTOP'
2023-12-15 23:17:21,121 [config.py:get_config_file_location()] - Passed config (-c): /home/biqu/KlipperScreen.conf
2023-12-15 23:17:21,124 [config.py:__init__()] - Config path location: /home/biqu/printer_data/config/KlipperScreen.conf
2023-12-15 23:17:21,173 [config.py:log_config()] -  ===== Config File =====

=======================
2023-12-15 23:17:21,176 [config.py:__init__()] - ====== Saved Def ======

[main]
print_sort_dir = date_asc

=======================
2023-12-15 23:17:21,178 [config.py:__init__()] - Configured printers: [
  {
    "Printer": {
      "moonraker_host": "127.0.0.1",
      "moonraker_port": "7125",
      "moonraker_api_key": ""
    }
  }
]
2023-12-15 23:17:21,434 [config.py:create_translations()] - Selected lang: None OS lang: en_US
2023-12-15 23:17:21,435 [config.py:install_language()] - Using system lang
2023-12-15 23:17:21,436 [config.py:install_language()] - Using lang en
2023-12-15 23:17:21,473 [screen.py:__init__()] - Screen resolution: 800x480
2023-12-15 23:17:21,477 [KlippyGtk.py:__init__()] - Font size: 16.6 (medium)
2023-12-15 23:17:22,885 [screen.py:set_screenblanking_timeout()] - Changing screen blanking to: 3600
2023-12-15 23:17:22,899 [screen.py:set_screenblanking_timeout()] - Using DPMS
2023-12-15 23:17:22,910 [screen.py:initial_connection()] - Default printer: None
2023-12-15 23:17:22,910 [screen.py:connect_printer()] - Connecting to printer: Printer
2023-12-15 23:17:22,911 [screen.py:_load_panel()] - Loading panel: splash_screen
2023-12-15 23:17:23,011 [screen.py:attach_panel()] - Current panel hierarchy: splash_screen
2023-12-15 23:17:23,028 [KlippyWebsocket.py:connect()] - Attempting to connect
2023-12-15 23:17:23,061 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-15 23:17:23,082 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/access/oneshot_token
2023-12-15 23:17:23,085 [KlippyWebsocket.py:connect()] - Starting websocket thread
2023-12-15 23:17:23,100 [_logging.py:info()] - Websocket connected
2023-12-15 23:17:23,101 [KlippyWebsocket.py:on_open()] - Moonraker Websocket Open
2023-12-15 23:17:23,375 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-15 23:17:23,396 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-15 23:17:23,398 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'octoprint_compat', 'authorization', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-15 23:17:23,417 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-15 23:17:23,419 [printer.py:configure_cameras()] - Cameras: []
2023-12-15 23:17:23,420 [screen.py:init_printer()] - Klipper not connected
2023-12-15 23:17:26,856 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-15 23:17:26,875 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-15 23:17:26,877 [screen.py:init_printer()] - Moonraker info {'klippy_connected': False, 'klippy_state': 'disconnected', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'octoprint_compat', 'authorization', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-15 23:17:26,895 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-15 23:17:26,897 [printer.py:configure_cameras()] - Cameras: []
2023-12-15 23:17:26,897 [screen.py:init_printer()] - Klipper not connected
2023-12-15 23:17:29,860 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-15 23:17:29,885 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-15 23:17:29,887 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'octoprint_compat', 'authorization', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-15 23:17:29,966 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-15 23:17:29,968 [printer.py:configure_cameras()] - Cameras: []
2023-12-15 23:17:29,968 [screen.py:init_printer()] - Klipper not connected
2023-12-15 23:17:32,859 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-15 23:17:32,880 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/info
2023-12-15 23:17:32,882 [screen.py:init_printer()] - Moonraker info {'klippy_connected': True, 'klippy_state': 'startup', 'components': ['klippy_connection', 'application', 'websockets', 'internal_transport', 'dbus_manager', 'database', 'file_manager', 'klippy_apis', 'secrets', 'template', 'shell_command', 'machine', 'data_store', 'proc_stats', 'job_state', 'job_queue', 'http_client', 'announcements', 'webcam', 'extensions', 'history', 'octoprint_compat', 'authorization', 'update_manager'], 'failed_components': [], 'registered_directories': ['config', 'logs', 'gcodes', 'config_examples', 'docs'], 'warnings': [], 'websocket_count': 2, 'moonraker_version': 'v0.8.0-188-ga71c5c1', 'missing_klippy_requirements': [], 'api_version': [1, 3, 0], 'api_version_string': '1.3.0'}
2023-12-15 23:17:32,903 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/webcams/list
2023-12-15 23:17:32,905 [printer.py:configure_cameras()] - Cameras: []
2023-12-15 23:17:32,928 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/info
2023-12-15 23:17:32,973 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?configfile
2023-12-15 23:17:32,978 [screen.py:init_printer()] - {'configfile': {'config': {'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {}, 'display_status': {}, 'respond': {}, 'gcode_macro CANCEL_PRINT': {'description': 'Cancel the actual running print', 'rename_existing': 'CANCEL_PRINT_BASE', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE'}, 'gcode_macro PAUSE': {'description': 'Pause the actual running print', 'rename_existing': 'PAUSE_BASE', 'variable_restore_idle_timeout': '0', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}'}, 'gcode_macro RESUME': {'description': 'Resume the actual running print', 'rename_existing': 'RESUME_BASE', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}", 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}'}, 'gcode_macro SET_PAUSE_NEXT_LAYER': {'description': 'Enable a pause if the next layer is reached', 'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"'}, 'gcode_macro SET_PAUSE_AT_LAYER': {'description': 'Enable/disable a pause if a given layer number is reached', 'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"'}, 'gcode_macro SET_PRINT_STATS_INFO': {'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }', 'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}'}, 'gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL': {'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT', 'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}'}, 'gcode_macro _CLIENT_EXTRUDE': {'description': 'Extrudes, if the extruder is hot enough', 'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}"}, 'gcode_macro _CLIENT_RETRACT': {'description': 'Retracts, if the extruder is hot enough', 'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}"}, 'mcu CB1': {'serial': '/tmp/klipper_host_mcu'}, 'board_pins EBB36_G0B1_v1.1': {'mcu': 'can0', 'aliases': '', 'aliases_step': '\nEXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15', 'aliases_limitsw': '\nLIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6', 'aliases_bltouch': '\nPROBE_1=PB9,PROBE_2=PB8', 'aliases_fans': '\nFAN0=PA1,FAN1=PA0', 'aliases_thermistors': '\nTH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7', 'aliases_heaters': '\nHE0=PB13', 'aliases_rgb': '\nRGBLED=PD3', 'aliases_adxl': '\nADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11', 'aliases_i2c': '\nAUX0=PB3,AUX1=PB4'}, 'mcu can0': {'canbus_uuid': '468039d874b8'}, 'temperature_sensor CANBOARD': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0'}, 'heater_fan hotend_fan': {'pin': 'can0:FAN0', 'max_power': '1.0', 'kick_start_time': '0.5', 'heater': 'extruder', 'heater_temp': '50.0'}, 'fan': {'pin': 'can0:FAN1', 'kick_start_time': '0.25', 'cycle_time': '0.15', 'off_below': '0.10'}, 'extruder': {'step_pin': 'can0:EXT_STEP', 'dir_pin': 'can0:EXT_DIR', 'enable_pin': '!can0:EXT_EN', 'rotation_distance': '4.637', 'nozzle_diameter': '0.400', 'filament_diameter': '1.750', 'max_extrude_only_distance': '500', 'max_extrude_only_velocity': '120', 'pressure_advance': '0.025', 'pressure_advance_smooth_time': '0.03', 'microsteps': '16', 'full_steps_per_rotation': '200', 'max_extrude_only_accel': '1500', 'max_extrude_cross_section': '5', 'heater_pin': 'can0:HE0', 'sensor_pin': 'can0:TH0', 'sensor_type': 'ATC Semitec 104GT-2', 'control': 'pid', 'pid_kp': '35.972', 'pid_ki': '14.107', 'pid_kd': '22.932', 'min_temp': '-50', 'max_temp': '350'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'interpolate': 'true', 'run_current': '0.85', 'hold_current': '0.100', 'sense_resistor': '0.11', 'stealthchop_threshold': '0'}, 'adxl345': {'cs_pin': 'can0:ADXL_CS', 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_mosi_pin': 'can0:ADXL_MOSI', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'axes_map': 'x,y,z'}, 'resonance_tester': {'accel_chip': 'adxl345', 'probe_points': '\n175,175,20'}, 'firmware_retraction': {'retract_length': '0.8', 'retract_speed': '10', 'unretract_extra_length': '0', 'unretract_speed': '10'}, 'mcu': {'canbus_uuid': '26b18d5aec60'}, 'printer': {'kinematics': 'corexy', 'max_velocity': '300', 'max_accel': '3000', 'max_z_velocity': '15', 'max_z_accel': '350', 'square_corner_velocity': '5.0'}, 'temperature_sensor MCU': {'sensor_type': 'temperature_mcu'}, 'temperature_sensor SoC': {'sensor_type': 'temperature_host'}, 'thermistor NTC10K': {'temperature1': '0.0', 'resistance1': '32116.0', 'temperature2': '40.0', 'resistance2': '5309.0', 'temperature3': '80.0', 'resistance3': '1228.0'}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'sensor_pin': 'PA4', 'min_temp': '0', 'max_temp': '100', 'gcode_id': 'C'}, 'exclude_object': {}, 'gcode_arcs': {'resolution': '0.1'}, 'bed_mesh': {'speed': '150', 'horizontal_move_z': '5', 'mesh_min': '35, 12', 'mesh_max': '320, 320', 'probe_count': '5, 5', 'algorithm': 'bicubic'}, 'stepper_x': {'step_pin': 'PE2', 'dir_pin': 'PB4', 'enable_pin': '!PC11', 'rotation_distance': '39.66', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': 'can0:LIMIT_3', 'homing_retract_dist': '5', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_y': {'step_pin': 'PF12', 'dir_pin': 'PF11', 'enable_pin': '!PB3', 'rotation_distance': '39.84', 'microsteps': '32', 'full_steps_per_rotation': '400', 'endstop_pin': '!PF4', 'position_min': '0', 'position_endstop': '350', 'position_max': '350', 'homing_speed': '25', 'homing_retract_dist': '0', 'homing_positive_dir': 'true'}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'interpolate': 'True', 'run_current': '0.8', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z': {'step_pin': 'PD11', 'dir_pin': '!PD9', 'enable_pin': '!PD15', 'rotation_distance': '4', 'microsteps': '32', 'endstop_pin': 'probe:z_virtual_endstop', 'position_max': '250', 'position_min': '-2.5', 'homing_speed': '8.0', 'second_homing_speed': '3', 'homing_retract_dist': '3'}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'interpolate': 'false', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z1': {'step_pin': 'PC9', 'dir_pin': '!PC8', 'enable_pin': '!PD1', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'stepper_z2': {'step_pin': 'PD7', 'dir_pin': '!PD6', 'enable_pin': '!PF10', 'rotation_distance': '4', 'microsteps': '32'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'interpolate': 'False', 'run_current': '0.6', 'sense_resistor': '0.110', 'stealthchop_threshold': '0'}, 'heater_bed': {'heater_pin': 'PB5', 'sensor_type': 'Generic 3950', 'sensor_pin': 'PA0', 'max_power': '0.7', 'min_temp': '0', 'max_temp': '120', 'control': 'pid', 'pid_kp': '40.654', 'pid_ki': '1.243', 'pid_kd': '332.343'}, 'output_pin caselight': {'pin': 'PB6', 'pwm': 'true', 'shutdown_value': '0', 'cycle_time': '0.01'}, 'idle_timeout': {'timeout': '1800'}, 'z_tilt': {'z_positions': '\n-50, 18\n175, 398\n400, 18', 'points': '\n30, 15\n175, 295\n320, 15', 'speed': '200', 'horizontal_move_z': '10', 'retries': '5', 'retry_tolerance': '0.0075'}, 'board_pins': {'aliases': '\n\nEXP1_1=PE9, EXP1_2=PE10,\nEXP1_3=PE11, EXP1_4=PE12,\nEXP1_5=PE13, EXP1_6=PE14,\nEXP1_7=PE15, EXP1_8=PB10,\nEXP1_9=<GND>, EXP1_10=<5V>,\n\n\nEXP2_1=PB14, EXP2_2=PB13,\nEXP2_3=PF7, EXP2_4=PB12,\nEXP2_5=PE7, EXP2_6=PB11,\nEXP2_7=PE8, EXP2_8=<RST>,\nEXP2_9=<GND>, EXP2_10=PC5'}, 'gcode_macro PRINT_START': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90'}, 'gcode_macro PRINT_END': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END'}, 'gcode_macro Level_Session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS'}, 'gcode_macro _CASELIGHT_ON': {'description': 'Helper: Light on', 'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}'}, 'gcode_macro _CASELIGHT_OFF': {'description': 'Helper: Light off', 'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}'}, 'gcode_macro CASELIGHT': {'description': 'Toggle light', 'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}"}, 'gcode_macro FAKE_POSITION': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10'}, 'gcode_macro T0': {'gcode': ''}, 'probe': {'pin': 'can0:PROBE_2', 'x_offset': '-29.8', 'y_offset': '-13.5', 'speed': '5', 'samples': '3', 'sample_retract_dist': '2', 'lift_speed': '5.0', 'samples_result': 'median', 'samples_tolerance': '0.02', 'samples_tolerance_retries': '5', 'z_offset': '-0.310'}, 'gcode_macro BED_MESH_CALIBRATE': {'rename_existing': '_BED_MESH_CALIBRATE', 'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}'}, 'gcode_macro LINE_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro VORON_PURGE': {'description': 'A purge macro that adapts to be near your actual printed objects', 'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}'}, 'gcode_macro SMART_PARK': {'description': 'Parks your printhead near the print area for pre-print hotend heating.', 'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}'}, 'gcode_macro _KAMP_Settings': {'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10', 'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}'}, 'force_move': {'enable_force_move': 'True'}, 'skew_correction': {}, 'bed_mesh default': {'version': '1', 'points': '\n-0.076250, -0.090625, -0.085000\n-0.095625, -0.118750, -0.112500\n-0.044375, -0.082500, -0.095625', 'x_count': '3', 'y_count': '3', 'mesh_x_pps': '2', 'mesh_y_pps': '2', 'algo': 'lagrange', 'tension': '0.2', 'min_x': '120.00000000000001', 'max_x': '230.0', 'min_y': '120.0', 'max_y': '230.0'}, 'skew_correction my_skew_profile': {'xy_skew': '0.0', 'xz_skew': '0.0', 'yz_skew': '0.0'}}, 'settings': {'mcu': {'canbus_uuid': '26b18d5aec60', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'mcu cb1': {'serial': '/tmp/klipper_host_mcu', 'max_stepper_error': 2.5e-05}, 'mcu can0': {'canbus_uuid': '468039d874b8', 'canbus_interface': 'can0', 'max_stepper_error': 2.5e-05}, 'virtual_sdcard': {'path': '~/printer_data/gcodes', 'on_error_gcode': 'CANCEL_PRINT'}, 'pause_resume': {'recover_velocity': 50.0}, 'respond': {'default_type': 'echo', 'default_prefix': 'echo:'}, 'gcode_macro cancel_print': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set allow_park = client.park_at_cancel|default(false)|lower == \'true\' %}\n{% set retract = client.cancel_retract|default(5.0)|abs %}\n\n{% set park_x = "" if (client.park_at_cancel_x|default(none) is none)\nelse "X=" ~ client.park_at_cancel_x %}\n{% set park_y = "" if (client.park_at_cancel_y|default(none) is none)\nelse "Y=" ~ client.park_at_cancel_y %}\n{% set custom_park = park_x|length > 0 or park_y|length > 0 %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if (custom_park or not printer.pause_resume.is_paused) and allow_park %} _TOOLHEAD_PARK_PAUSE_CANCEL {park_x} {park_y} {% endif %}\n_CLIENT_RETRACT LENGTH={retract}\nTURN_OFF_HEATERS\nM106 S0\n\nSET_PAUSE_NEXT_LAYER ENABLE=0\nSET_PAUSE_AT_LAYER ENABLE=0 LAYER=0\nCANCEL_PRINT_BASE', 'rename_existing': 'CANCEL_PRINT_BASE', 'description': 'Cancel the actual running print'}, 'gcode_macro pause': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set idle_timeout = client.idle_timeout|default(0) %}\n{% set temp = printer[printer.toolhead.extruder].target if printer.toolhead.extruder != \'\' else 0%}\n{% set restore = False if printer.toolhead.extruder == \'\'\nelse True  if params.RESTORE|default(1)|int == 1 else False %}\n\nSET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE="{{\'restore\': restore, \'temp\': temp}}"\n\n{% if idle_timeout > 0 %}\nSET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}\nSET_IDLE_TIMEOUT TIMEOUT={idle_timeout}\n{% endif %}\nPAUSE_BASE\n_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}', 'rename_existing': 'PAUSE_BASE', 'description': 'Pause the actual running print', 'variable_restore_idle_timeout': '0'}, 'gcode_macro resume': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set sp_move = client.speed_move|default(velocity) %}\n\n\n{% if printer[\'gcode_macro PAUSE\'].restore_idle_timeout > 0 %}\nSET_IDLE_TIMEOUT TIMEOUT={printer[\'gcode_macro PAUSE\'].restore_idle_timeout}\n{% endif %}\n{% if printer.idle_timeout.state|upper == "IDLE" %}\n{% if last_extruder_temp.restore %} M109 S{last_extruder_temp.temp} {% endif %}\n{% endif %}\n_CLIENT_EXTRUDE\nRESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}', 'rename_existing': 'RESUME_BASE', 'description': 'Resume the actual running print', 'variable_last_extruder_temp': "{'restore': False, 'temp': 0}"}, 'gcode_macro set_pause_next_layer': {'gcode': '\n{% set pause_next_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_next_layer %}\n{% set ENABLE = params.ENABLE|default(1)|int != 0 %}\n{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ \'enable\': ENABLE, \'call\': MACRO }}"', 'description': 'Enable a pause if the next layer is reached'}, 'gcode_macro set_pause_at_layer': {'gcode': '\n{% set pause_at_layer = printer[\'gcode_macro SET_PRINT_STATS_INFO\'].pause_at_layer %}\n{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined\nelse params.LAYER is defined %}\n{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}\n{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}\nSET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ \'enable\': ENABLE, \'layer\': LAYER, \'call\': MACRO }}"', 'description': 'Enable/disable a pause if a given layer number is reached'}, 'gcode_macro set_print_stats_info': {'gcode': '\n{% if pause_next_layer.enable %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_next_layer" % pause_next_layer.call}\'\n{pause_next_layer.call}\nSET_PAUSE_NEXT_LAYER ENABLE=0\n{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}\nRESPOND TYPE=echo MSG=\'{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}\'\n{pause_at_layer.call}\nSET_PAUSE_AT_LAYER ENABLE=0\n{% endif %}\nSET_PRINT_STATS_INFO_BASE {rawparams}', 'rename_existing': 'SET_PRINT_STATS_INFO_BASE', 'description': 'Overwrite, to get pause_next_layer and pause_at_layer feature', 'variable_pause_next_layer': '{ \'enable\': False, \'call\': "PAUSE" }', 'variable_pause_at_layer': '{ \'enable\': False, \'layer\': 0, \'call\': "PAUSE" }'}, 'gcode_macro _toolhead_park_pause_cancel': {'gcode': '\n\n{% set client = printer[\'gcode_macro _CLIENT_VARIABLE\']|default({}) %}\n{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}\n{% set use_custom     = client.use_custom_pos|default(false)|lower == \'true\' %}\n{% set custom_park_x  = client.custom_park_x|default(0.0) %}\n{% set custom_park_y  = client.custom_park_y|default(0.0) %}\n{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}\n{% set sp_hop         = client.speed_hop|default(15) * 60 %}\n{% set sp_move        = client.speed_move|default(velocity) * 60 %}\n\n{% set origin    = printer.gcode_move.homing_origin %}\n{% set act       = printer.gcode_move.gcode_position %}\n{% set max       = printer.toolhead.axis_maximum %}\n{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}\n{% set round_bed = True if printer.configfile.settings.printer.kinematics is in [\'delta\',\'polar\',\'rotary_delta\',\'winch\']\nelse False %}\n\n{% set z_min = params.Z_MIN|default(0)|float %}\n{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}\n{% set x_park = params.X       if params.X is defined\nelse custom_park_x  if use_custom\nelse 0.0            if round_bed\nelse (max.x - 5.0) %}\n{% set y_park = params.Y       if params.Y is defined\nelse custom_park_y  if use_custom\nelse (max.y - 5.0)  if round_bed and z_park < cone\nelse 0.0            if round_bed\nelse (max.y - 5.0) %}\n\n_CLIENT_RETRACT\n{% if "xyz" in printer.toolhead.homed_axes %}\nG90\nG1 Z{z_park} F{sp_hop}\nG1 X{x_park} Y{y_park} F{sp_move}\n{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}\n{% else %}\nRESPOND TYPE=echo MSG=\'Printer not homed\'\n{% endif %}', 'description': 'Helper: park toolhead used in PAUSE and CANCEL_PRINT'}, 'gcode_macro _client_extrude': {'gcode': "\n\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}\n{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}\n{% set absolute_extrude = printer.gcode_move.absolute_extrude %}\n\n{% if printer.toolhead.extruder != '' %}\n{% if printer[printer.toolhead.extruder].can_extrude %}\n{% if use_fw_retract %}\n{% if length < 0 %}\nG10\n{% else %}\nG11\n{% endif %}\n{% else %}\nM83\nG1 E{length} F{(speed|float|abs) * 60}\n{% if absolute_extrude %}\nM82\n{% endif %}\n{% endif %}\n{% else %}\nRESPOND TYPE=echo MSG='Extruder not hot enough'\n{% endif %}\n{% endif %}", 'description': 'Extrudes, if the extruder is hot enough'}, 'gcode_macro _client_retract': {'gcode': "\n{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}\n{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}\n{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}\n\n_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}", 'description': 'Retracts, if the extruder is hot enough'}, 'board_pins ebb36_g0b1_v1.1': {'mcu': ['can0'], 'aliases': [], 'aliases_step': [['EXT_EN', 'PD2'], ['EXT_STEP', 'PD0'], ['EXT_DIR', 'PD1'], ['EXT_UART', 'PA15']], 'aliases_limitsw': [['LIMIT_1', 'PB7'], ['LIMIT_2', 'PB5'], ['LIMIT_3', 'PB6']], 'aliases_bltouch': [['PROBE_1', 'PB9'], ['PROBE_2', 'PB8']], 'aliases_fans': [['FAN0', 'PA1'], ['FAN1', 'PA0']], 'aliases_thermistors': [['TH0', 'PA3'], ['PT100_CS', 'PA4'], ['PT100_SCLK', 'PA5'], ['PT100_MISO', 'PA6'], ['PT100_MOSI', 'PA7']], 'aliases_heaters': [['HE0', 'PB13']], 'aliases_rgb': [['RGBLED', 'PD3']], 'aliases_adxl': [['ADXL_CS', 'PB12'], ['ADXL_SCLK', 'PB10'], ['ADXL_MISO', 'PB2'], ['ADXL_MOSI', 'PB11']], 'aliases_i2c': [['AUX0', 'PB3'], ['AUX1', 'PB4']]}, 'temperature_sensor canboard': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'can0', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'heater_fan hotend_fan': {'heater': ['extruder'], 'heater_temp': 50.0, 'max_power': 1.0, 'kick_start_time': 0.5, 'off_below': 0.0, 'cycle_time': 0.01, 'hardware_pwm': False, 'shutdown_speed': 1.0, 'pin': 'can0:FAN0', 'fan_speed': 1.0}, 'fan': {'max_power': 1.0, 'kick_start_time': 0.25, 'off_below': 0.1, 'cycle_time': 0.15, 'hardware_pwm': False, 'shutdown_speed': 0.0, 'pin': 'can0:FAN1'}, 'tmc2209 extruder': {'uart_pin': 'can0:EXT_UART', 'uart_address': 0, 'run_current': 0.85, 'hold_current': 0.1, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'extruder': {'microsteps': 16, 'sensor_type': 'ATC Semitec 104GT-2', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'can0:TH0', 'min_temp': -50.0, 'max_temp': 350.0, 'min_extrude_temp': 170.0, 'max_power': 1.0, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 35.972, 'pid_ki': 14.107, 'pid_kd': 22.932, 'heater_pin': 'can0:HE0', 'pwm_cycle_time': 0.1, 'nozzle_diameter': 0.4, 'filament_diameter': 1.75, 'max_extrude_cross_section': 5.0, 'max_extrude_only_velocity': 120.0, 'max_extrude_only_accel': 1500.0, 'max_extrude_only_distance': 500.0, 'instantaneous_corner_velocity': 1.0, 'step_pin': 'can0:EXT_STEP', 'pressure_advance': 0.025, 'pressure_advance_smooth_time': 0.03, 'dir_pin': 'can0:EXT_DIR', 'rotation_distance': 4.637, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!can0:EXT_EN'}, 'adxl345': {'axes_map': ['x', 'y', 'z'], 'rate': 3200, 'cs_pin': 'can0:ADXL_CS', 'spi_speed': 5000000, 'spi_software_sclk_pin': 'can0:ADXL_SCLK', 'spi_software_miso_pin': 'can0:ADXL_MISO', 'spi_software_mosi_pin': 'can0:ADXL_MOSI'}, 'resonance_tester': {'move_speed': 50.0, 'min_freq': 5.0, 'max_freq': 133.33333333333334, 'accel_per_hz': 75.0, 'hz_per_sec': 1.0, 'probe_points': [[175.0, 175.0, 20.0]], 'accel_chip': 'adxl345'}, 'firmware_retraction': {'retract_length': 0.8, 'retract_speed': 10.0, 'unretract_extra_length': 0.0, 'unretract_speed': 10.0}, 'temperature_sensor mcu': {'sensor_type': 'temperature_mcu', 'sensor_mcu': 'mcu', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'temperature_sensor soc': {'sensor_type': 'temperature_host', 'sensor_path': '/sys/class/thermal/thermal_zone0/temp', 'min_temp': -273.15, 'max_temp': 99999999.9}, 'thermistor ntc10k': {'temperature1': 0.0, 'resistance1': 32116.0, 'temperature2': 40.0, 'resistance2': 5309.0, 'temperature3': 80.0, 'resistance3': 1228.0}, 'temperature_sensor chamber': {'sensor_type': 'NTC10K', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA4', 'min_temp': 0.0, 'max_temp': 100.0, 'gcode_id': 'C'}, 'gcode_arcs': {'resolution': 0.1}, 'bed_mesh': {'probe_count': [5, 5], 'mesh_min': [35.0, 12.0], 'mesh_max': [320.0, 320.0], 'mesh_pps': [2, 2], 'algorithm': 'bicubic', 'bicubic_tension': 0.2, 'horizontal_move_z': 5.0, 'speed': 150.0, 'fade_start': 1.0, 'fade_end': 0.0, 'split_delta_z': 0.025, 'move_check_distance': 5.0}, 'bed_mesh default': {'version': 1, 'points': [[-0.07625, -0.090625, -0.085], [-0.095625, -0.11875, -0.1125], [-0.044375, -0.0825, -0.095625]], 'min_x': 120.00000000000001, 'max_x': 230.0, 'min_y': 120.0, 'max_y': 230.0, 'x_count': 3, 'y_count': 3, 'mesh_x_pps': 2, 'mesh_y_pps': 2, 'algo': 'lagrange', 'tension': 0.2}, 'tmc2209 stepper_x': {'uart_pin': 'PC10', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_x': {'microsteps': 32, 'step_pin': 'PE2', 'dir_pin': 'PB4', 'rotation_distance': 39.66, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PC11', 'endstop_pin': 'can0:LIMIT_3', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 5.0, 'homing_positive_dir': True}, 'tmc2209 stepper_y': {'uart_pin': 'PF13', 'uart_address': 0, 'run_current': 0.8, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': True, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_y': {'microsteps': 32, 'step_pin': 'PF12', 'dir_pin': 'PF11', 'rotation_distance': 39.84, 'full_steps_per_rotation': 400, 'gear_ratio': [], 'enable_pin': '!PB3', 'endstop_pin': '!PF4', 'position_endstop': 350.0, 'position_min': 0.0, 'position_max': 350.0, 'homing_speed': 25.0, 'second_homing_speed': 12.5, 'homing_retract_speed': 25.0, 'homing_retract_dist': 0.0, 'homing_positive_dir': True}, 'tmc2209 stepper_z': {'uart_pin': 'PD14', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z': {'microsteps': 32, 'step_pin': 'PD11', 'dir_pin': '!PD9', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD15', 'endstop_pin': 'probe:z_virtual_endstop', 'position_min': -2.5, 'position_max': 250.0, 'homing_speed': 8.0, 'second_homing_speed': 3.0, 'homing_retract_speed': 8.0, 'homing_retract_dist': 3.0, 'homing_positive_dir': False}, 'tmc2209 stepper_z1': {'uart_pin': 'PD0', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z1': {'microsteps': 32, 'step_pin': 'PC9', 'dir_pin': '!PC8', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PD1'}, 'tmc2209 stepper_z2': {'uart_pin': 'PF9', 'uart_address': 0, 'run_current': 0.6, 'hold_current': 2.0, 'sense_resistor': 0.11, 'interpolate': False, 'stealthchop_threshold': 0.0, 'driver_multistep_filt': True, 'driver_toff': 3, 'driver_hstrt': 5, 'driver_hend': 0, 'driver_tbl': 2, 'driver_iholddelay': 8, 'driver_pwm_ofs': 36, 'driver_pwm_grad': 14, 'driver_pwm_freq': 1, 'driver_pwm_autoscale': True, 'driver_pwm_autograd': True, 'driver_pwm_reg': 8, 'driver_pwm_lim': 12, 'driver_tpowerdown': 20, 'driver_sgthrs': 0}, 'stepper_z2': {'microsteps': 32, 'step_pin': 'PD7', 'dir_pin': '!PD6', 'rotation_distance': 4.0, 'full_steps_per_rotation': 200, 'gear_ratio': [], 'enable_pin': '!PF10'}, 'heater_bed': {'sensor_type': 'Generic 3950', 'pullup_resistor': 4700.0, 'inline_resistor': 0.0, 'sensor_pin': 'PA0', 'min_temp': 0.0, 'max_temp': 120.0, 'min_extrude_temp': 170.0, 'max_power': 0.7, 'smooth_time': 1.0, 'control': 'pid', 'pid_kp': 40.654, 'pid_ki': 1.243, 'pid_kd': 332.343, 'heater_pin': 'PB5', 'pwm_cycle_time': 0.1}, 'verify_heater heater_bed': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 60.0}, 'output_pin caselight': {'pwm': True, 'pin': 'PB6', 'cycle_time': 0.01, 'hardware_pwm': False, 'scale': 1.0, 'maximum_mcu_duration': 0.0, 'value': 0.0, 'shutdown_value': 0.0}, 'idle_timeout': {'timeout': 1800.0, 'gcode': "\n{% if 'heaters' in printer %}\n   TURN_OFF_HEATERS\n{% endif %}\nM84\n"}, 'z_tilt': {'z_positions': [[-50.0, 18.0], [175.0, 398.0], [400.0, 18.0]], 'retries': 5, 'retry_tolerance': 0.0075, 'points': [[30.0, 15.0], [175.0, 295.0], [320.0, 15.0]], 'horizontal_move_z': 10.0, 'speed': 200.0}, 'board_pins': {'mcu': ['mcu'], 'aliases': [['EXP1_1', 'PE9'], ['EXP1_2', 'PE10'], ['EXP1_3', 'PE11'], ['EXP1_4', 'PE12'], ['EXP1_5', 'PE13'], ['EXP1_6', 'PE14'], ['EXP1_7', 'PE15'], ['EXP1_8', 'PB10'], ['EXP1_9', '<GND>'], ['EXP1_10', '<5V>'], ['EXP2_1', 'PB14'], ['EXP2_2', 'PB13'], ['EXP2_3', 'PF7'], ['EXP2_4', 'PB12'], ['EXP2_5', 'PE7'], ['EXP2_6', 'PB11'], ['EXP2_7', 'PE8'], ['EXP2_8', '<RST>'], ['EXP2_9', '<GND>'], ['EXP2_10', 'PC5']]}, 'gcode_macro print_start': {'gcode': '\n\n{% set target_bed = params.BED|int %}\n{% set target_extruder = params.EXTRUDER|int %}\n{% set target_chamber = params.CHAMBER|default("40")|int %}\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\nG28\nG90\n\n\n\n\n\n{% if params.BED|int > 90 %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nM106 S255\n\n\n\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Heatsoak: {target_chamber}c"\nTEMPERATURE_WAIT SENSOR="temperature_sensor chamber" MINIMUM={target_chamber}\n\n\n{% else %}\nSET_DISPLAY_TEXT MSG="Bed: {target_bed}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM190 S{target_bed}\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n{% endif %}\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\n\n\n\n\n\n\n\n\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\n\nSET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nM107\nM109 S{target_extruder}\n\n\nSET_DISPLAY_TEXT MSG="Printer goes brr"\n\n\n\n\n\n\nVORON_PURGE\nG90', 'description': 'G-Code macro'}, 'gcode_macro print_end': {'gcode': '\n\n\n\n{% set th = printer.toolhead %}\n{% set x_safe = th.position.x + 20 * (1 if th.axis_maximum.x - th.position.x > 20 else -1) %}\n{% set y_safe = th.position.y + 20 * (1 if th.axis_maximum.y - th.position.y > 20 else -1) %}\n{% set z_safe = [th.position.z + 2, th.axis_maximum.z]|min %}\n\nSAVE_GCODE_STATE NAME=STATE_PRINT_END\n\nM400\nG92 E0\nG1 E-0.4 F3600\n\nTURN_OFF_HEATERS\n\nG90\nG0 X{x_safe} Y{y_safe} Z{z_safe} F20000\nG0 X{th.axis_maximum.x//2} Y{th.axis_maximum.y - 2} F3600\nM107\n\nBED_MESH_CLEAR\nRESTORE_GCODE_STATE NAME=STATE_PRINT_END', 'description': 'G-Code macro'}, 'gcode_macro level_session': {'gcode': '\n\n{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}\n{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}\n\n\n\n\nG28\nG90\n\n\n\nM190 S60\n\nG1 X{x_wait} Y{y_wait} Z15 F9000\nSET_DISPLAY_TEXT MSG="Soak for 5min"\nG4 P300000\n\n\nSET_DISPLAY_TEXT MSG="Hotend: 150c"\nM109 S150\n\n\nSET_DISPLAY_TEXT MSG="Z-tilt adjust"\n\nZ_TILT_ADJUST\nG28 Z\n\n\nSET_DISPLAY_TEXT MSG="Bed mesh"\n\nbed_mesh_calibrate\n\nTURN_OFF_HEATERS', 'description': 'G-Code macro'}, 'gcode_macro _caselight_on': {'gcode': '\nSET_PIN PIN=caselight VALUE={printer[\'gcode_macro _USER_VARIABLE\'].peripheral.caselight.on_val}\n{action_respond_info("Caselight on")}', 'description': 'Helper: Light on'}, 'gcode_macro _caselight_off': {'gcode': '\nSET_PIN PIN=caselight VALUE=0.0\n{action_respond_info("Caselight off")}', 'description': 'Helper: Light off'}, 'gcode_macro caselight': {'gcode': "{% if printer['output_pin caselight'].value == 0 %} _CASELIGHT_ON {% else %} _CASELIGHT_OFF {% endif %}", 'description': 'Toggle light'}, 'gcode_macro fake_position': {'gcode': '\nSET_KINEMATIC_POSITION X=10 Y=10 Z=10', 'description': 'G-Code macro'}, 'gcode_macro t0': {'gcode': '', 'description': 'G-Code macro'}, 'probe': {'z_offset': -0.31, 'deactivate_on_each_sample': True, 'activate_gcode': '', 'deactivate_gcode': '', 'pin': 'can0:PROBE_2', 'speed': 5.0, 'lift_speed': 5.0, 'x_offset': -29.8, 'y_offset': -13.5, 'samples': 3, 'sample_retract_dist': 2.0, 'samples_result': 'median', 'samples_tolerance': 0.02, 'samples_tolerance_retries': 5}, 'gcode_macro bed_mesh_calibrate': {'gcode': '\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}\n{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}\n{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set probe_dock_enable = kamp_settings.probe_dock_enable | abs %}\n{% set attach_macro = kamp_settings.attach_macro | string %}\n{% set detach_macro = kamp_settings.detach_macro | string %}\n{% set mesh_margin = kamp_settings.mesh_margin | float %}\n{% set fuzz_amount = kamp_settings.fuzz_amount | float %}\n{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}\n{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}\n{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}\n{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}\n{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}\n{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}\n{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}\n\n{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}\n{% set adapted_x_min = x_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_y_min = y_min - mesh_margin - (fuzz_range | random / 100.0) %}\n{% set adapted_x_max = x_max + mesh_margin + (fuzz_range | random / 100.0) %}\n{% set adapted_y_max = y_max + mesh_margin + (fuzz_range | random / 100.0) %}\n\n{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}\n{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}\n{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}\n{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}\n\n{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method=\'ceil\') | int) + 1 %}\n{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method=\'ceil\') | int) + 1 %}\n\n{% if (([points_x, points_y]|max) > 6) %}\n{% set algorithm = "bicubic" %}\n{% set min_points = 4 %}\n{% else %}\n{% set algorithm = "lagrange" %}\n{% set min_points = 3 %}\n{% endif %}\n\n{% set points_x = [points_x , min_points]|max %}\n{% set points_y = [points_y , min_points]|max %}\n{% set points_x = [points_x , probe_count[0]]|min %}\n{% set points_y = [points_y , probe_count[1]]|min %}\n\n{% if verbose_enable == True %}\n{% if printer.exclude_object.objects != [] %}\n\n{ action_respond_info( "Algorithm: {}.".format(\n(algorithm),\n)) }\n\n{ action_respond_info("Default probe count: {},{}.".format(\n(probe_count[0]),\n(probe_count[1]),\n)) }\n\n{ action_respond_info("Adapted probe count: {},{}.".format(\n(points_x),\n(points_y),\n)) }\n\n{action_respond_info("Default mesh bounds: {}, {}.".format(\n(bed_mesh_min[0],bed_mesh_min[1]),\n(bed_mesh_max[0],bed_mesh_max[1]),\n)) }\n\n{% if mesh_margin > 0 %}\n{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(\n(mesh_margin),\n(mesh_margin),\n)) }\n{% else %}\n{action_respond_info("Mesh margin is 0, margin not increased.")}\n{% endif %}\n\n{% if fuzz_amount > 0 %}\n{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(\n(fuzz_amount),\n)) }\n{% else %}\n{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}\n{% endif %}\n\n{ action_respond_info("Adapted mesh bounds: {}, {}.".format(\n(adapted_x_min, adapted_y_min),\n(adapted_x_max, adapted_y_max),\n)) }\n\n{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}\n\n{% else %}\n\n{action_respond_info("No objects detected! Check your gcode and make sure that EXCLUDE_OBJECT_DEFINE is happening before BED_MESH_CALIBRATE is called. Defaulting to regular meshing.")}\nG4 P5000\n{% endif %}\n\n{% endif %}\n\n{% if probe_dock_enable == True %}\n{attach_macro}\n{% endif %}\n\n_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}\n\n{% if probe_dock_enable == True %}\n{detach_macro}\n{% endif %}', 'rename_existing': '_BED_MESH_CALIBRATE', 'description': 'G-Code macro'}, 'gcode_macro line_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}\n{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}\n{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}\n{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}\n{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}\n{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}\n\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\n{% if purge_y_origin > 0 %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_center),\n(purge_y_origin),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% else %}\n\n{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(\n(purge_x_origin),\n(purge_y_center),\n(purge_amount),\n(flow_rate),\n)) }\n\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\n{% if purge_y_origin > 0 %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_center} Y{purge_y_origin}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 X{purge_x_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% else %}\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_center}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}\n{RETRACT}\nG0 Y{purge_y_center + purge_amount + 10} F{travel_speed}\nG92 E0\nM82\nG0 Z{purge_height * 2} F{travel_speed}\n\n{% endif %}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro voron_purge': {'gcode': '\n\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}\n\n\n{% if printer.firmware_retraction is defined %}\n{% set RETRACT = G10 | string %}\n{% set UNRETRACT = G11 | string %}\n{% else %}\n{% set RETRACT = \'G1 E-.5 F2100\' | string %}\n{% set UNRETRACT = \'G1 E.5 F2100\' | string %}\n{% endif %}\n\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set purge_height = kamp_settings.purge_height | float %}\n{% set tip_distance = kamp_settings.tip_distance | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set purge_amount = kamp_settings.purge_amount | float %}\n{% set flow_rate = kamp_settings.flow_rate | float %}\n{% set size = 10 | float %}\n\n\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}\n{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}\n{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}\n{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}\n\n{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}\n{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}\n\n{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}\n{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}\n\n\n{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}\n\n{% if cross_section < 5 %}\n\n{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}\n\n{% else %}\n\n{% if verbose_enable == True %}\n\n{action_respond_info("Moving filament tip {}mms".format(\n(tip_distance),\n)) }\n{% endif %}\n\n{% if printer.firmware_retraction is defined %}\n{action_respond_info("KAMP purge is using firmware retraction.")}\n{% else %}\n{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}\n{% endif %}\n\nSAVE_GCODE_STATE NAME=Prepurge_State\n\nG92 E0\nG0 F{travel_speed}\nG90\nG0 X{purge_x_origin} Y{purge_y_origin+size/2}\nG0 Z{purge_height}\nM83\nG1 E{tip_distance} F{purge_move_speed}\nG1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}\n{RETRACT}\nG0 Z{purge_height*2}\nG0 X{purge_x_origin+size*0.711} Y{purge_y_origin}\nG0 Z{purge_height}\n{UNRETRACT}\nG1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}\n{RETRACT}\nG92 E0\nM82\nG0 Z{purge_height*2} F{travel_speed}\n\nRESTORE_GCODE_STATE NAME=Prepurge_State\n\n{% endif %}', 'description': 'A purge macro that adapts to be near your actual printed objects'}, 'gcode_macro smart_park': {'gcode': '\n\n{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}\n{% set z_height = kamp_settings.smart_park_height | float %}\n{% set purge_margin = kamp_settings.purge_margin | float %}\n{% set verbose_enable = kamp_settings.verbose_enable | abs %}\n{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}\n{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}\n{% set axis_minimum_x = printer.toolhead.axis_minimum.x | float %}\n{% set axis_minimum_y = printer.toolhead.axis_minimum.y | float %}\n{% set all_points = printer.exclude_object.objects | map(attribute=\'polygon\') | sum(start=[]) %}\n{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}\n{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}\n{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}\n\n{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}\n{% set x_min = [ x_min - purge_margin , x_min ] | min %}\n{% set y_min = [ y_min - purge_margin , y_min ] | min %}\n{% set x_min = [ x_min , axis_minimum_x ] | max %}\n{% set y_min = [ y_min , axis_minimum_y ] | max %}\n{% endif %}\n\n\n{% if verbose_enable == True %}\n\n{ action_respond_info("Smart Park location: {},{}.".format(\n(x_min),\n(y_min),\n)) }\n\n{% endif %}\n\n{% if printer.toolhead.position.z < z_height %}\nG0 Z{z_height}\n{% endif %}\nG0 X{x_min} Y{y_min} F{travel_speed}\nG0 Z{z_height}', 'description': 'Parks your printhead near the print area for pre-print hotend heating.'}, 'gcode_macro _kamp_settings': {'gcode': '\n\n{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}', 'description': 'This macro contains all adjustable settings for KAMP', 'variable_verbose_enable': 'True', 'variable_mesh_margin': '0', 'variable_fuzz_amount': '0', 'variable_probe_dock_enable': 'False', 'variable_attach_macro': "'Attach_Probe'", 'variable_detach_macro': "'Dock_Probe'", 'variable_purge_height': '0.8', 'variable_tip_distance': '0', 'variable_purge_margin': '20', 'variable_purge_amount': '30', 'variable_flow_rate': '12', 'variable_smart_park_height': '10'}, 'force_move': {'enable_force_move': True}, 'skew_correction my_skew_profile': {'xy_skew': 0.0, 'xz_skew': 0.0, 'yz_skew': 0.0}, 'printer': {'max_velocity': 300.0, 'max_accel': 3000.0, 'max_accel_to_decel': 1500.0, 'square_corner_velocity': 5.0, 'buffer_time_low': 1.0, 'buffer_time_high': 2.0, 'buffer_time_start': 0.25, 'move_flush_time': 0.05, 'kinematics': 'corexy', 'max_z_velocity': 15.0, 'max_z_accel': 350.0}, 'verify_heater extruder': {'hysteresis': 5.0, 'max_error': 120.0, 'heating_gain': 2.0, 'check_gain_time': 20.0}}, 'warnings': [], 'save_config_pending': False, 'save_config_pending_items': {}}}
2023-12-15 23:17:32,984 [printer.py:reinit()] - Klipper version: v0.11.0-304-gf7567a0d
2023-12-15 23:17:32,984 [printer.py:reinit()] - # Extruders: 1
2023-12-15 23:17:32,985 [printer.py:reinit()] - # Temperature devices: 5
2023-12-15 23:17:32,986 [printer.py:reinit()] - # Fans: 2
2023-12-15 23:17:32,986 [printer.py:reinit()] - # Output pins: 1
2023-12-15 23:17:32,987 [printer.py:reinit()] - # Leds: 0
2023-12-15 23:17:33,026 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/gcode/help
2023-12-15 23:17:33,031 [KlippyWebsocket.py:object_subscription()] - Sending printer.objects.subscribe
2023-12-15 23:17:33,294 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/printer/objects/query?bed_mesh&configfile&display_status&extruder&fan&gcode_move&heater_bed&idle_timeout&pause_resume&print_stats&toolhead&virtual_sdcard&webhooks&motion_report&firmware_retraction&exclude_object&manual_probe&extruder&heater_bed&temperature_sensor CANBOARD&temperature_sensor MCU&temperature_sensor SoC&temperature_sensor chamber&fan&heater_fan hotend_fan&output_pin caselight
2023-12-15 23:17:33,322 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-12-15 23:17:33,325 [screen.py:init_tempstore()] - Tempstore not ready: {'result': {}} Retrying in 5 seconds
2023-12-15 23:17:33,328 [files.py:initialize()] - Gcodes path: /home/biqu/printer_data/gcodes
2023-12-15 23:17:33,329 [KlippyWebsocket.py:get_file_list()] - Sending server.files.list
2023-12-15 23:17:33,331 [screen.py:init_printer()] - Printer initialized
2023-12-15 23:17:33,332 [printer.py:change_state()] - Changing state from 'disconnected' to 'startup'
2023-12-15 23:17:33,333 [printer.py:change_state()] - Adding callback for state: startup
2023-12-15 23:17:34,962 [printer.py:change_state()] - Changing state from 'startup' to 'ready'
2023-12-15 23:17:34,962 [printer.py:change_state()] - Adding callback for state: ready
2023-12-15 23:17:34,968 [screen.py:_load_panel()] - Loading panel: main_menu
2023-12-15 23:17:35,107 [main_menu.py:__init__()] - ### Making MainMenu
2023-12-15 23:17:35,121 [main_menu.py:add_device()] - Adding device: extruder
2023-12-15 23:17:35,132 [main_menu.py:add_device()] - Adding device: heater_bed
2023-12-15 23:17:35,144 [main_menu.py:add_device()] - Adding device: temperature_sensor CANBOARD
2023-12-15 23:17:35,154 [main_menu.py:add_device()] - Adding device: temperature_sensor MCU
2023-12-15 23:17:35,164 [main_menu.py:add_device()] - Adding device: temperature_sensor SoC
2023-12-15 23:17:35,174 [main_menu.py:add_device()] - Adding device: temperature_sensor chamber
2023-12-15 23:17:35,245 [screen.py:attach_panel()] - Current panel hierarchy: main_menu
2023-12-15 23:17:35,248 [main_menu.py:update_graph_visibility()] - Could not create graph tempstore: []
2023-12-15 23:17:38,855 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/temperature_store
2023-12-15 23:17:38,883 [printer.py:init_temp_store()] - Temp store: ['temperature_sensor CANBOARD', 'temperature_sensor MCU', 'temperature_sensor SoC', 'temperature_sensor chamber', 'heater_bed', 'extruder']
2023-12-15 23:17:38,913 [KlippyRest.py:_do_request()] - Sending request to http://127.0.0.1:7125/server/config
2023-12-15 23:17:38,915 [screen.py:init_tempstore()] - Temperature store size: 1200
2023-12-23 10:49:31,321 [KlippyGtk.py:Dialog()] - Showing dialog Updating (width=804, height=480)
2023-12-23 10:49:54,118 [base_panel.py:process_update()] - Update complete
